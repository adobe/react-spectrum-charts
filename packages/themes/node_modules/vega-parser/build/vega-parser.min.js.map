{"version":3,"file":"vega-parser.min.js","sources":["../src/parsers/autosize.js","../src/parsers/padding.js","../src/parsers/encode/util.js","../src/parsers/marks/roles.js","../src/parsers/encode/defaults.js","../src/parsers/encode/entry.js","../src/parsers/encode.js","../src/parsers/encode/rule.js","../src/parsers/signal.js","../src/util.js","../src/parsers/stream.js","../src/parsers/update.js","../src/parsers/signal-updates.js","../src/transforms.js","../src/parsers/scale.js","../src/parsers/projection.js","../src/parsers/guides/constants.js","../src/parsers/marks/marktypes.js","../src/parsers/guides/guide-group.js","../src/parsers/guides/guide-util.js","../src/parsers/guides/guide-mark.js","../src/parsers/guides/legend-gradient.js","../src/parsers/guides/legend-gradient-discrete.js","../src/parsers/guides/legend-gradient-labels.js","../src/parsers/guides/legend-symbol-groups.js","../src/parsers/guides/legend-title.js","../src/parsers/marks/clip.js","../src/parsers/marks/role.js","../src/parsers/marks/definition.js","../src/parsers/marks/interactive.js","../src/parsers/transform.js","../src/parsers/marks/data.js","../src/DataScope.js","../src/parsers/trigger.js","../src/parsers/mark.js","../src/parsers/marks/facet.js","../src/parsers/marks/subflow.js","../src/parsers/legend.js","../src/parsers/title.js","../src/parsers/data.js","../src/parsers/guides/axis-util.js","../src/parsers/guides/axis-config.js","../src/parsers/guides/axis-domain.js","../src/parsers/guides/axis-grid.js","../src/parsers/guides/axis-labels.js","../src/parsers/guides/axis-title.js","../src/parsers/axis.js","../src/parsers/guides/axis-ticks.js","../src/parsers/scope.js","../src/parsers/view.js","../src/Scope.js","../src/config.js","../src/parse.js"],"sourcesContent":["import {isObject} from 'vega-util';\n\nexport default function(spec) {\n  return isObject(spec) ? spec : {type: spec || 'pad'};\n}\n","import {isObject} from 'vega-util';\n\nconst number = _ => +_ || 0;\n\nconst paddingObject = _ => ({top: _, bottom: _, left: _, right: _});\n\nexport default function(spec) {\n  return !isObject(spec) ? paddingObject(number(spec))\n    : spec.signal ? spec\n    : {\n        top:    number(spec.top),\n        bottom: number(spec.bottom),\n        left:   number(spec.left),\n        right:  number(spec.right)\n      };\n}\n","import {extend, hasOwnProperty, isArray, isObject} from 'vega-util';\n\nexport const encoder = _ => isObject(_) && !isArray(_)\n  ? extend({}, _)\n  : {value: _};\n\nexport function addEncode(object, name, value, set) {\n  if (value != null) {\n    const isEncoder = (\n      (isObject(value) && !isArray(value)) ||\n      (isArray(value) && value.length && isObject(value[0]))\n    );\n\n    // Always assign signal to update, even if the signal is from the enter block\n    if (isEncoder) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {value: value};\n    }\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function addEncoders(object, enter, update) {\n  for (const name in enter) {\n    addEncode(object, name, enter[name]);\n  }\n  for (const name in update) {\n    addEncode(object, name, update[name], 'update');\n  }\n}\n\nexport function extendEncode(encode, extra, skip) {\n  for (const name in extra) {\n    if (skip && hasOwnProperty(skip, name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n  return encode;\n}\n\nexport function has(key, encode) {\n  return encode && (\n    (encode.enter && encode.enter[key]) ||\n    (encode.update && encode.update[key])\n  );\n}\n","export const MarkRole = 'mark';\nexport const FrameRole = 'frame';\nexport const ScopeRole = 'scope';\n\nexport const AxisRole = 'axis';\nexport const AxisDomainRole = 'axis-domain';\nexport const AxisGridRole = 'axis-grid';\nexport const AxisLabelRole = 'axis-label';\nexport const AxisTickRole = 'axis-tick';\nexport const AxisTitleRole = 'axis-title';\n\nexport const LegendRole = 'legend';\nexport const LegendBandRole = 'legend-band';\nexport const LegendEntryRole = 'legend-entry';\nexport const LegendGradientRole = 'legend-gradient';\nexport const LegendLabelRole = 'legend-label';\nexport const LegendSymbolRole = 'legend-symbol';\nexport const LegendTitleRole = 'legend-title';\n\nexport const TitleRole = 'title';\nexport const TitleTextRole = 'title-text';\nexport const TitleSubtitleRole = 'title-subtitle';\n","import {has} from './util';\nimport {FrameRole, MarkRole} from '../marks/roles';\nimport {array, extend} from 'vega-util';\n\nexport default function(encode, type, role, style, config) {\n  const defaults = {}, enter = {};\n  let update, key, skip, props;\n\n  // if text mark, apply global lineBreak settings (#2370)\n  key = 'lineBreak';\n  if (type === 'text' && config[key] != null && !has(key, encode)) {\n    applyDefault(defaults, key, config[key]);\n  }\n\n  // ignore legend and axis roles\n  if (role == 'legend' || String(role).startsWith('axis')) {\n    role = null;\n  }\n\n  // resolve mark config\n  props = role === FrameRole ? config.group\n    : (role === MarkRole) ? extend({}, config.mark, config[type])\n    : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode)\n      || (key === 'fill' || key === 'stroke')\n      && (has('fill', encode) || has('stroke', encode));\n\n    if (!skip) applyDefault(defaults, key, props[key]);\n  }\n\n  // resolve styles, apply with increasing precedence\n  array(style).forEach(name => {\n    const props = config.style && config.style[name];\n    for (const key in props) {\n      if (!has(key, encode)) {\n        applyDefault(defaults, key, props[key]);\n      }\n    }\n  });\n\n  encode = extend({}, encode); // defensive copy\n  for (key in defaults) {\n    props = defaults[key];\n    if (props.signal) {\n      (update = update || {})[key] = props;\n    } else {\n      enter[key] = props;\n    }\n  }\n\n  encode.enter = extend(enter, encode.enter);\n  if (update) encode.update = extend(update, encode.update);\n\n  return encode;\n}\n\nfunction applyDefault(defaults, key, value) {\n  defaults[key] = value && value.signal\n    ? {signal: value.signal}\n    : {value: value};\n}\n","import {error, isObject, isString, peek, splitAccessPath, stringValue} from 'vega-util';\n\nconst scaleRef = scale => isString(scale) ? stringValue(scale)\n  : scale.signal ? `(${scale.signal})`\n  : field(scale);\n\nexport default function entry(enc) {\n  if (enc.gradient != null) {\n    return gradient(enc);\n  }\n\n  let value = enc.signal ? `(${enc.signal})`\n    : enc.color ? color(enc.color)\n    : enc.field != null ? field(enc.field)\n    : enc.value !== undefined ? stringValue(enc.value)\n    : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = `pow(${value},${property(enc.exponent)})`;\n  }\n\n  if (enc.mult != null) {\n    value += `*${property(enc.mult)}`;\n  }\n\n  if (enc.offset != null) {\n    value += `+${property(enc.offset)}`;\n  }\n\n  if (enc.round) {\n    value = `round(${value})`;\n  }\n\n  return value;\n}\n\nconst _color = (type, x, y, z) =>\n  `(${type}(${[x, y, z].map(entry).join(',')})+'')`;\n\nfunction color(enc) {\n  return (enc.c) ? _color('hcl', enc.h, enc.c, enc.l)\n    : (enc.h || enc.s) ? _color('hsl', enc.h, enc.s, enc.l)\n    : (enc.l || enc.a) ? _color('lab', enc.l, enc.a, enc.b)\n    : (enc.r || enc.g || enc.b) ? _color('rgb', enc.r, enc.g, enc.b)\n    : null;\n}\n\nfunction gradient(enc) {\n  // map undefined to null; expression lang does not allow undefined\n  const args = [enc.start, enc.stop, enc.count]\n    .map(_ => _ == null ? null : stringValue(_));\n\n  // trim null inputs from the end\n  while (args.length && peek(args) == null) args.pop();\n\n  args.unshift(scaleRef(enc.gradient));\n  return `gradient(${args.join(',')})`;\n}\n\nfunction property(property) {\n  return isObject(property) ? '(' + entry(property) + ')' : property;\n}\n\nfunction field(ref) {\n  return resolveField(isObject(ref) ? ref : {datum: ref});\n}\n\nfunction resolveField(ref) {\n  let object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = ref.signal;\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    field = isString(field)\n      ? splitAccessPath(field).map(stringValue).join('][')\n      : resolveField(field);\n  }\n\n  return object + '[' + field + ']';\n}\n\nfunction scale(enc, value) {\n  const scale = scaleRef(enc.scale);\n\n  if (enc.range != null) {\n    // pull value from scale range\n    value = `lerp(_range(${scale}), ${+enc.range})`;\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = `_scale(${scale}, ${value})`;\n\n    if (enc.band) {\n      value = (value ? value + '+' : '')\n        + `_bandwidth(${scale})`\n        + (+enc.band === 1 ? '' : '*' + property(enc.band));\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n","import applyDefaults from './encode/defaults';\nimport entry from './encode/entry';\nimport rule from './encode/rule';\n\nimport {parseExpression} from 'vega-functions';\nimport {extend, isArray} from 'vega-util';\n\nexport default function(encode, type, role, style, scope, params) {\n  const enc = {};\n  params = params || {};\n  params.encoders = {$encode: enc};\n\n  encode = applyDefaults(encode, type, role, style, scope.config);\n  for (const key in encode) {\n    enc[key] = parseBlock(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction parseBlock(block, marktype, params, scope) {\n  const channels = {},\n        fields = {};\n\n  for (const name in block) {\n    if (block[name] != null) { // skip any null entries\n      channels[name] = parse(expr(block[name]), scope, params, fields);\n    }\n  }\n\n  return {\n    $expr:   {marktype, channels},\n    $fields: Object.keys(fields),\n    $output: Object.keys(block)\n  };\n}\n\nfunction expr(enc) {\n  return isArray(enc) ? rule(enc) : entry(enc);\n}\n\nfunction parse(code, scope, params, fields) {\n  const expr = parseExpression(code, scope);\n  expr.$fields.forEach(name => fields[name] = 1);\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n","import entry from './entry';\nimport {peek} from 'vega-util';\n\nexport default function(enc) {\n  let code = '';\n\n  enc.forEach(rule => {\n    const value = entry(rule);\n    code += rule.test ? `(${rule.test})?${value}:` : value;\n  });\n\n  // if no else clause, terminate with null (#1366)\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return code;\n}\n","import {error, stringValue} from 'vega-util';\n\nconst OUTER = 'outer',\n      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nexport default function(signal, scope) {\n  const name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name);\n    // signal push must not use properties reserved for standard definition\n    OUTER_INVALID.forEach(prop => {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    const op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n","import {isObject} from 'vega-util';\n\nexport function Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\n\nexport function entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\n\nexport function operator(value, params) {\n  return entry('operator', value, params);\n}\n\n// -----\n\nexport function ref(op) {\n  const ref = {$ref: op.id};\n  // if operator not yet registered, cache ref to resolve later\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\n\nexport const tupleidRef = {\n  $tupleid: 1,\n  toString: function() { return ':_tupleid_:'; }\n};\n\nexport function fieldRef(field, name) {\n  return name ? {$field: field, $name: name} : {$field: field};\n}\n\nexport const keyFieldRef = fieldRef('key');\n\nexport function compareRef(fields, orders) {\n  return {$compare: fields, $order: orders};\n}\n\nexport function keyRef(fields, flat) {\n  const ref = {$key: fields};\n  if (flat) ref.$flat = true;\n  return ref;\n}\n\n// -----\n\nexport const Ascending  = 'ascending';\n\nexport const Descending = 'descending';\n\nexport function sortKey(sort) {\n  return !isObject(sort) ? ''\n    : (sort.order === Descending ? '-' : '+')\n      + aggrField(sort.op, sort.field);\n}\n\nexport function aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '')\n    + (op && field ? '_' : '')\n    + (field && field.signal ? '$' + field.signal : field || '');\n}\n\n// -----\n\nexport const Scope = 'scope';\n\nexport const View = 'view';\n\nexport function isSignal(_) {\n  return _ && _.signal;\n}\n\nexport function isExpr(_) {\n  return _ && _.expr;\n}\n\nexport function hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (const key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\n\nexport function value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\n\nexport function deref(v) {\n  return v && v.signal || v;\n}\n","import {Scope, View} from '../util';\nimport {parseExpression} from 'vega-functions';\nimport {error, stringValue} from 'vega-util';\n\nconst Timer = 'timer';\n\nexport default function parseStream(stream, scope) {\n  const method = stream.merge ? mergeStream\n    : stream.stream ? nestedStream\n    : stream.type ? eventStream\n    : error('Invalid stream specification: ' + stringValue(stream));\n\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n   return source === Scope ? View : (source || View);\n}\n\nfunction mergeStream(stream, scope) {\n  const list = stream.merge.map(s => parseStream(s, scope)),\n        entry = streamParameters({merge: list}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  const id = parseStream(stream.stream, scope),\n        entry = streamParameters({stream: id}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  let id;\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {between: stream.between, filter: stream.filter};\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  const entry = streamParameters({stream: id}, stream, scope);\n  return Object.keys(entry).length === 1\n    ? id\n    : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  let param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n    entry.between = [\n      parseStream(param[0], scope),\n      parseStream(param[1], scope)\n    ];\n  }\n\n  param = stream.filter ? [].concat(stream.filter) : [];\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n  if (stream.source === Scope) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')', scope).$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  const item = 'event.item';\n  return item\n    + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '')\n    + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '')\n    + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n","import parseStream from './stream';\nimport {Scope, View} from '../util';\nimport {parseSelector} from 'vega-event-selector';\nimport {parseExpression} from 'vega-functions';\nimport {array, error, extend, isString, stringValue} from 'vega-util';\n\n// bypass expression parser for internal operator references\nconst OP_VALUE_EXPR = {\n  code: '_.$value',\n  ast: {type: 'Identifier', value: 'value'}\n};\n\nexport default function(spec, scope, target) {\n  const encode = spec.encode,\n        entry = {target: target};\n\n  let events = spec.events,\n      update = spec.update,\n      sources = [];\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  }\n\n  // interpret as an event selector string\n  if (isString(events)) {\n    events = parseSelector(events, scope.isSubscope() ? Scope : View);\n  }\n\n  // separate event streams from signal updates\n  events = array(events)\n    .filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);\n\n  // merge internal operator listeners\n  if (sources.length > 1) {\n    sources = [mergeSources(sources)];\n  }\n\n  // merge event streams, include as source\n  if (events.length) {\n    sources.push(events.length > 1 ? {merge: events} : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  }\n\n  // resolve update value\n  entry.update = isString(update) ? parseExpression(update, scope)\n    : update.expr != null ? parseExpression(update.expr, scope)\n    : update.value != null ? update.value\n    : update.signal != null ? {\n        $expr:   OP_VALUE_EXPR,\n        $params: {$value: scope.signalRef(update.signal)}\n      }\n    : error('Invalid signal update specification.');\n\n  if (spec.force) {\n    entry.options = {force: true};\n  }\n\n  sources.forEach(source =>\n    scope.addUpdate(extend(streamSource(source, scope), entry))\n  );\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal)\n          : stream.scale ? scope.scaleRef(stream.scale)\n          : parseStream(stream, scope)\n  };\n}\n\nfunction mergeSources(sources) {\n  return {\n    signal: '['\n      + sources.map(s => s.scale ? 'scale(\"' + s.scale + '\")' : s.signal)\n      + ']'\n  };\n}\n","import parseUpdate from './update';\nimport {parseExpression} from 'vega-functions';\nimport {error} from 'vega-util';\n\nexport default function(signal, scope) {\n  const op = scope.getSignal(signal.name);\n  let expr = signal.update;\n\n  if (signal.init) {\n    if (expr) {\n      error('Signals can not include both init and update expressions.');\n    } else {\n      expr = signal.init;\n      op.initonly = true;\n    }\n  }\n\n  if (expr) {\n    expr = parseExpression(expr, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(_ => parseUpdate(_, scope, op.id));\n  }\n}\n","import {entry} from './util';\n\nconst transform = name => (params, value, parent) =>\n  entry(name, value, params || undefined, parent);\n\nexport const Aggregate = transform('aggregate');\nexport const AxisTicks = transform('axisticks');\nexport const Bound = transform('bound');\nexport const Collect = transform('collect');\nexport const Compare = transform('compare');\nexport const DataJoin = transform('datajoin');\nexport const Encode = transform('encode');\nexport const Expression = transform('expression');\nexport const Extent = transform('extent');\nexport const Facet = transform('facet');\nexport const Field = transform('field');\nexport const Key = transform('key');\nexport const LegendEntries = transform('legendentries');\nexport const Load = transform('load');\nexport const Mark = transform('mark');\nexport const MultiExtent = transform('multiextent');\nexport const MultiValues = transform('multivalues');\nexport const Overlap = transform('overlap');\nexport const Params = transform('params');\nexport const PreFacet = transform('prefacet');\nexport const Projection = transform('projection');\nexport const Proxy = transform('proxy');\nexport const Relay = transform('relay');\nexport const Render = transform('render');\nexport const Scale = transform('scale');\nexport const Sieve = transform('sieve');\nexport const SortItems = transform('sortitems');\nexport const ViewLayout = transform('viewlayout');\nexport const Values = transform('values');\n","import {\n  Aggregate, Collect, MultiExtent, MultiValues, Sieve, Values\n} from '../transforms';\nimport {aggrField, keyFieldRef, ref} from '../util';\n\nimport {isDiscrete, isQuantile, isValidScaleType} from 'vega-scale';\nimport {\n  error, extend, hasOwnProperty, isArray, isObject, isString, stringValue\n} from 'vega-util';\n\nlet FIELD_REF_ID = 0;\n\nconst MULTIDOMAIN_SORT_OPS  = {min: 'min', max: 'max', count: 'sum'};\n\nexport function initScale(spec, scope) {\n  const type = spec.type || 'linear';\n\n  if (!isValidScaleType(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type,\n    domain: undefined\n  });\n}\n\nexport function parseScale(spec, scope) {\n  const params = scope.getScale(spec.name).params;\n  let key;\n\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    params.nice = parseScaleNice(spec.nice, scope);\n  }\n\n  if (spec.bins != null) {\n    params.bins = parseScaleBins(spec.bins, scope);\n  }\n\n  for (key in spec) {\n    if (hasOwnProperty(params, key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v\n    : v.signal ? scope.signalRef(v.signal)\n    : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal\n    ? scope.signalRef(v.signal)\n    : v.map(v => parseLiteral(v, scope));\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal)\n    : (isArray(domain) ? explicitDomain\n    : domain.fields ? multipleDomain\n    : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(v => parseLiteral(v, scope));\n}\n\nfunction singularDomain(domain, spec, scope) {\n  const data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n\n  return isDiscrete(spec.type)\n      ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false))\n      : isQuantile(spec.type) ? data.domainRef(scope, domain.field)\n      : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  const data = domain.data,\n        fields = domain.fields.reduce((dom, d) => {\n          d = isString(d) ? {data: data, field: d}\n            : (isArray(d) || d.signal) ? fieldRef(d, scope)\n            : d;\n          dom.push(d);\n          return dom;\n        }, []);\n\n  return (isDiscrete(spec.type) ? ordinalMultipleDomain\n    : isQuantile(spec.type) ? quantileMultipleDomain\n    : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  const name = '_:vega:_' + (FIELD_REF_ID++),\n        coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {$ingest: data};\n  } else if (data.signal) {\n    const code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {data: name, field: 'data'};\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  const sort = parseSort(domain.sort, true);\n  let a, v;\n\n  // get value counts for each domain field\n  const counts = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field, sort);\n  });\n\n  // aggregate the results from each domain field\n  const p = {groupby: keyFieldRef, pulse: counts};\n  if (sort) {\n    a = sort.op || 'count';\n    v = sort.field ? aggrField(a, sort.field) : 'count';\n    p.ops = [MULTIDOMAIN_SORT_OPS[a]];\n    p.fields = [scope.fieldRef(v)];\n    p.as = [v];\n  }\n  a = scope.add(Aggregate(p));\n\n  // collect aggregate output\n  const c = scope.add(Collect({pulse: ref(a)}));\n\n  // extract values for combined domain\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort:  scope.sortRef(sort),\n    pulse: ref(c)\n  }));\n\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';\n      else sort = {field: 'key'};\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {\n        error('Multiple domain scales can not be sorted using ' + sort.op);\n      }\n    }\n  }\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  const values = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return ref(scope.add(MultiValues({values: values})));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  const extents = fields.map(f => {\n    const data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return ref(scope.add(MultiExtent({extents: extents})));\n}\n\n// -- SCALE BINS -----\n\nfunction parseScaleBins(v, scope) {\n  return v.signal || isArray(v)\n    ? parseArray(v, scope)\n    : scope.objectProperty(v);\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice, scope) {\n  return nice.signal\n    ? scope.signalRef(nice.signal)\n    : isObject(nice)\n    ? {\n        interval: parseLiteral(nice.interval),\n        step: parseLiteral(nice.step)\n      }\n    : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  const config = scope.config.range;\n  let range = spec.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && hasOwnProperty(config, range)) {\n      spec = extend({}, spec, {range: config[range]});\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {signal: 'width'}];\n    } else if (range === 'height') {\n      range = isDiscrete(spec.type)\n        ? [0, {signal: 'height'}]\n        : [{signal: 'height'}, 0];\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = isArray(range.scheme)\n      ? parseArray(range.scheme, scope)\n      : parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isDiscrete(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(v => (isArray(v) ? parseArray : parseLiteral)(v, scope));\n}\n","import {error, isArray, isObject, stringValue} from 'vega-util';\n\nexport default function(proj, scope) {\n  const config = scope.config.projection || {},\n        params = {};\n\n  for (const name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter(proj[name], name, scope);\n  }\n\n  // apply projection defaults from config\n  for (const name in config) {\n    if (params[name] == null) {\n      params[name] = parseParameter(config[name], name, scope);\n    }\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter(_, name, scope) {\n  return isArray(_) ? _.map(_ => parseParameter(_, name, scope))\n    : !isObject(_) ? _\n    : _.signal ? scope.signalRef(_.signal)\n    : name === 'fit' ? _\n    : error('Unsupported parameter object: ' + stringValue(_));\n}\n","export const Top = 'top';\nexport const Left = 'left';\nexport const Right = 'right';\nexport const Bottom = 'bottom';\nexport const Center = 'center';\n\nexport const Vertical = 'vertical';\n\nexport const Start = 'start';\nexport const Middle = 'middle';\nexport const End = 'end';\n\nexport const Index  = 'index';\nexport const Label  = 'label';\nexport const Offset = 'offset';\nexport const Perc   = 'perc';\nexport const Perc2  = 'perc2';\nexport const Value  = 'value';\n\nexport const GuideLabelStyle = 'guide-label';\nexport const GuideTitleStyle = 'guide-title';\nexport const GroupTitleStyle = 'group-title';\nexport const GroupSubtitleStyle = 'group-subtitle';\n\n/** All values of LegendType */\nexport const Symbols = 'symbol';\nexport const Gradient = 'gradient';\nexport const Discrete = 'discrete';\n\nexport const Size = 'size';\nexport const Shape = 'shape';\nexport const Fill = 'fill';\nexport const Stroke = 'stroke';\nexport const StrokeWidth = 'strokeWidth';\nexport const StrokeDash = 'strokeDash';\nexport const Opacity = 'opacity';\n\n// Encoding channels supported by legends\n// In priority order of 'canonical' scale\nexport const LegendScales = [\n  Size,\n  Shape,\n  Fill,\n  Stroke,\n  StrokeWidth,\n  StrokeDash,\n  Opacity\n];\n\nexport const Skip = {\n  name: 1,\n  style: 1,\n  interactive: 1\n};\n\nexport const zero = {value: 0};\nexport const one = {value: 1};\n","export const GroupMark = 'group';\nexport const RectMark = 'rect';\nexport const RuleMark = 'rule';\nexport const SymbolMark = 'symbol';\nexport const TextMark = 'text';\n","import {GroupMark} from '../marks/marktypes';\n\nexport default function(mark) {\n  mark.type = GroupMark;\n  mark.interactive = mark.interactive || false;\n  return mark;\n}\n","import {Center, End, Left, Right, Start, Vertical} from './constants';\nimport {value} from '../../util';\nimport {isObject, stringValue} from 'vega-util';\n\nexport function lookup(spec, config) {\n  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));\n\n  _.isVertical = s => Vertical === value(\n    spec.direction,\n    config.direction || (s ? config.symbolDirection : config.gradientDirection)\n  );\n\n  _.gradientLength = () => value(\n    spec.gradientLength,\n    config.gradientLength || config.gradientWidth\n  );\n\n  _.gradientThickness = () => value(\n    spec.gradientThickness,\n    config.gradientThickness || config.gradientHeight\n  );\n\n  _.entryColumns = () => value(\n    spec.columns,\n    value(config.columns, +_.isVertical(true))\n  );\n\n  return _;\n}\n\nexport function getEncoding(name, encode) {\n  const v = encode && (\n    (encode.update && encode.update[name]) ||\n    (encode.enter && encode.enter[name])\n  );\n  return v && v.signal ? v : v ? v.value : null;\n}\n\nexport function getStyle(name, scope, style) {\n  const s = scope.config.style[style];\n  return s && s[name];\n}\n\nexport function anchorExpr(s, e, m) {\n  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;\n}\n\nexport const alignExpr = anchorExpr(\n  stringValue(Left),\n  stringValue(Right),\n  stringValue(Center)\n);\n\nexport function tickBand(_) {\n  const v = _('tickBand');\n  let offset = _('tickOffset'),\n      band, extra;\n\n  if (!v) {\n    // if no tick band entry, fall back on other properties\n    band = _('bandPosition');\n    extra = _('tickExtra');\n  } else if (v.signal) {\n    // if signal, augment code to interpret values\n    band = {signal: `(${v.signal}) === 'extent' ? 1 : 0.5`};\n    extra = {signal: `(${v.signal}) === 'extent'`};\n    if (!isObject(offset)) {\n      offset = {signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`};\n    }\n  } else if (v === 'extent') {\n    // if constant, simply set values\n    band = 1;\n    extra = true;\n    offset = 0;\n  } else {\n    band = 0.5;\n    extra = false;\n  }\n\n  return {extra, band, offset};\n}\n\nexport function extendOffset(value, offset) {\n  return !offset ? value\n    : !value ? offset\n    : !isObject(value) ? { value, offset }\n    : Object.assign({}, value, { offset: extendOffset(value.offset, offset) });\n}\n","import {Skip} from './constants';\nimport {extendEncode} from '../encode/util';\n\nexport default function(mark, extras) {\n  if (extras) {\n    mark.name = extras.name;\n    mark.style = extras.style || mark.style;\n    mark.interactive = !!extras.interactive;\n    mark.encode = extendEncode(mark.encode, extras, Skip);\n  } else {\n    mark.interactive = false;\n  }\n  return mark;\n}\n","import {one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendGradientRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: one,\n      fill: {gradient: scale, start: start, stop: stop}\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    stroke:      _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, { // update\n    opacity:     _('gradientOpacity')\n  });\n\n  return guideMark({\n    type: RectMark,\n    role: LegendGradientRole,\n    encode\n  }, userEncode);\n}\n","import {Perc, Perc2, Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendBandRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = _.gradientThickness(),\n        length = _.gradientLength();\n\n  let u, v, uu, vv, adjust = '';\n\n  vertical\n    ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-')\n    : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n\n  const enter = {\n    opacity: zero,\n    fill: {scale: scale, field: Value}\n  };\n  enter[u]  = {signal: adjust + 'datum.' + Perc, mult: length};\n  enter[v]  = zero;\n  enter[uu] = {signal: adjust + 'datum.' + Perc2, mult: length};\n  enter[vv] = encoder(thickness);\n\n  const encode = {\n    enter: enter,\n    update: extend({}, enter, {opacity: one}),\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:      _('gradientStrokeColor'),\n    strokeWidth: _('gradientStrokeWidth')\n  }, { // update\n    opacity:     _('gradientOpacity')\n  });\n\n  return guideMark({\n    type: RectMark,\n    role: LegendBandRole,\n    key:  Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n","import {\n  Bottom, Center, GuideLabelStyle, Index, Label, Left, Middle,\n  Perc, Right, Top, Value, one, zero\n} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendLabelRole} from '../marks/roles';\nimport {value} from '../../util';\n\nconst alignExpr = `datum.${Perc}<=0?\"${Left}\":datum.${Perc}>=1?\"${Right}\":\"${Center}\"`,\n      baselineExpr = `datum.${Perc}<=0?\"${Bottom}\":datum.${Perc}>=1?\"${Top}\":\"${Middle}\"`;\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        vertical = _.isVertical(),\n        thickness = encoder(_.gradientThickness()),\n        length = _.gradientLength();\n\n  let overlap = _('labelOverlap'),\n      enter, update, u, v, adjust = '';\n\n  const encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: one,\n      text: {field: Label}\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontStyle:   _('labelFontStyle'),\n    fontWeight:  _('labelFontWeight'),\n    limit:       value(spec.labelLimit, config.gradientLabelLimit)\n  });\n\n  if (vertical) {\n    enter.align = {value: 'left'};\n    enter.baseline = update.baseline = {signal: baselineExpr};\n    u = 'y'; v = 'x'; adjust = '1-';\n  } else {\n    enter.align = update.align = {signal: alignExpr};\n    enter.baseline = {value: 'top'};\n    u = 'x'; v = 'y';\n  }\n\n  enter[u] = update[u] = {signal: adjust + 'datum.' + Perc, mult: length};\n\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n\n  overlap = overlap ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.' + Index\n  } : undefined;\n\n  // type, role, style, key, dataRef, encode, extras\n  return guideMark({\n    type:  TextMark,\n    role:  LegendLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from: dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n","import {\n  GuideLabelStyle, Index, Label, LegendScales, Offset, Size, Skip,\n  Value, one, zero\n} from './constants';\nimport guideGroup from './guide-group';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder, extendEncode} from '../encode/util';\nimport {SymbolMark, TextMark} from '../marks/marktypes';\nimport {LegendLabelRole, LegendSymbolRole, ScopeRole} from '../marks/roles';\n\n// userEncode is top-level, includes entries, symbols, labels\nexport default function(spec, config, userEncode, dataRef, columns) {\n  const _ = lookup(spec, config),\n        entries = userEncode.entries,\n        interactive = !!(entries && entries.interactive),\n        name = entries ? entries.name : undefined,\n        height = _('clipHeight'),\n        symbolOffset = _('symbolOffset'),\n        valueRef = {data: 'value'},\n        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,\n        yEncode = height ? encoder(height) : {field: Size},\n        index = `datum.${Index}`,\n        ncols = `max(1, ${columns})`;\n\n  let encode, enter, update, nrows, sort;\n\n  yEncode.mult = 0.5;\n\n  // -- LEGEND SYMBOLS --\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, mult: 0.5, offset: symbolOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  let baseFill = null,\n      baseStroke = null;\n  if (!spec.fill) {\n    baseFill = config.symbolBaseFillColor;\n    baseStroke = config.symbolBaseStrokeColor;\n  }\n\n  addEncoders(encode, {\n    fill:             _('symbolFillColor', baseFill),\n    shape:            _('symbolType'),\n    size:             _('symbolSize'),\n    stroke:           _('symbolStrokeColor', baseStroke),\n    strokeDash:       _('symbolDash'),\n    strokeDashOffset: _('symbolDashOffset'),\n    strokeWidth:      _('symbolStrokeWidth')\n  }, { // update\n    opacity:          _('symbolOpacity')\n  });\n\n  LegendScales.forEach(scale => {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {scale: spec[scale], field: Value};\n    }\n  });\n\n  const symbols = guideMark({\n    type: SymbolMark,\n    role: LegendSymbolRole,\n    key:  Value,\n    from: valueRef,\n    clip: height ? true : undefined,\n    encode\n  }, userEncode.symbols);\n\n  // -- LEGEND LABELS --\n  const labelOffset = encoder(symbolOffset);\n  labelOffset.offset = _('labelOffset');\n\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, offset: labelOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncoders(encode, {\n    align:       _('labelAlign'),\n    baseline:    _('labelBaseline'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontStyle:   _('labelFontStyle'),\n    fontWeight:  _('labelFontWeight'),\n    limit:       _('labelLimit')\n  });\n\n  const labels = guideMark({\n    type:  TextMark,\n    role:  LegendLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from:  valueRef,\n    encode\n  }, userEncode.labels);\n\n  // -- LEGEND ENTRY GROUPS --\n  encode = {\n    enter: {\n      noBound: {value: !height}, // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {opacity: zero},\n    update: update = {\n      opacity: one,\n      row: {signal: null},\n      column: {signal: null}\n    }\n  };\n\n  // annotate and sort groups to ensure correct ordering\n  if (_.isVertical(true)) {\n    nrows = `ceil(item.mark.items.length / ${ncols})`;\n    update.row.signal = `${index}%${nrows}`;\n    update.column.signal = `floor(${index} / ${nrows})`;\n    sort = {field: ['row', index]};\n  } else {\n    update.row.signal = `floor(${index} / ${ncols})`;\n    update.column.signal = `${index} % ${ncols}`;\n    sort = {field: index};\n  }\n  // handle zero column case (implies infinite columns)\n  update.column.signal = `(${columns})?${update.column.signal}:${index}`;\n\n  // facet legend entries into sub-groups\n  dataRef = {facet: {data: dataRef, name: 'value', groupby: Index}};\n\n  return guideGroup({\n    role:   ScopeRole,\n    from:   dataRef,\n    encode: extendEncode(encode, entries, Skip),\n    marks:  [symbols, labels],\n    name,\n    interactive,\n    sort\n  });\n}\n\nexport function legendSymbolLayout(spec, config) {\n  const _ = lookup(spec, config);\n\n  // layout parameters for legend entries\n  return {\n    align:   _('gridAlign'),\n    columns: _.entryColumns(),\n    center:  {\n      row: true,\n      column: false\n    },\n    padding: {\n      row:    _('rowPadding'),\n      column: _('columnPadding')\n    }\n  };\n}\n","import {GuideTitleStyle, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {alignExpr, anchorExpr, lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendTitleRole} from '../marks/roles';\n\n// expression logic for align, anchor, angle, and baseline calculation\nconst isL = 'item.orient === \"left\"',\n      isR = 'item.orient === \"right\"',\n      isLR = `(${isL} || ${isR})`,\n      isVG = `datum.vgrad && ${isLR}`,\n      baseline = anchorExpr('\"top\"', '\"bottom\"', '\"middle\"'),\n      alignFlip = anchorExpr('\"right\"', '\"left\"', '\"center\"'),\n      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? \"left\" : ${alignExpr}`,\n      exprAnchor = `item._anchor || (${isLR} ? \"middle\" : \"start\")`,\n      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,\n      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? \"bottom\" : \"top\") : ${baseline}) : \"top\"`;\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config);\n\n  const encode = {\n    enter: {opacity: zero},\n    update: {\n      opacity: one,\n      x: {field: {group: 'padding'}},\n      y: {field: {group: 'padding'}}\n    },\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    orient:      _('titleOrient'),\n    _anchor:     _('titleAnchor'),\n    anchor:      {signal: exprAnchor},\n    angle:       {signal: exprAngle},\n    align:       {signal: exprAlign},\n    baseline:    {signal: exprBaseline},\n    text:        spec.title,\n    fill:        _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font:        _('titleFont'),\n    fontSize:    _('titleFontSize'),\n    fontStyle:   _('titleFontStyle'),\n    fontWeight:  _('titleFontWeight'),\n    limit:       _('titleLimit'),\n    lineHeight:  _('titleLineHeight')\n  }, { // require update\n    align:       _('titleAlign'),\n    baseline:    _('titleBaseline')\n  });\n\n  return guideMark({\n    type:  TextMark,\n    role:  LegendTitleRole,\n    style: GuideTitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n","import {isObject, stringValue} from 'vega-util';\n\nexport default function(clip, scope) {\n  let expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr\n    ? scope.signalRef(expr)\n    : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal\n    ? value.signal\n    : stringValue(value);\n}","import {GroupMark} from './marktypes';\nimport {MarkRole, ScopeRole} from './roles';\n\nexport default function(spec) {\n  const role = spec.role || '';\n  return (role.startsWith('axis') || role.startsWith('legend') || role.startsWith('title'))\n    ? role\n    : spec.type === GroupMark ? ScopeRole : (role || MarkRole);\n}\n","import role from './role';\n\nexport default function(spec) {\n  return {\n    marktype:     spec.type,\n    name:         spec.name || undefined,\n    role:         spec.role || role(spec),\n    zindex:       +spec.zindex || undefined,\n    aria:         spec.aria,\n    description:  spec.description\n  };\n}\n","export default function(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal)\n    : spec === false ? false\n    : true;\n}\n","import {Params} from '../transforms';\nimport {entry, fieldRef, isSignal, ref} from '../util';\nimport {definition} from 'vega-dataflow';\nimport {parseExpression} from 'vega-functions';\nimport {error, extend, isArray, isString, stringValue} from 'vega-util';\n\n/**\n * Parse a data transform specification.\n */\nexport default function(spec, scope) {\n  const def = definition(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n\n  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n\n  return t;\n}\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  const params = {},\n        n = def.params.length;\n\n  for (let i = 0; i < n; ++i) {\n    const pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\nfunction parseParameter(def, spec, scope) {\n  const type = def.type,\n        value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type)\n          + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value)\n    ? value.map(v => parameterValue(def, v, scope))\n    : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  const type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.')\n         : isField(type) ? scope.fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : scope.signalRef(value.signal);\n  } else {\n    const expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as)\n         : expr && outerField(value) ? fieldRef(value.field, value.as)\n         : isExpr(type) ? parseExpression(value, scope)\n         : isData(type) ? ref(scope.getData(value).values)\n         : isField(type) ? fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  const value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) { // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(v => parseSubParameter(def, v, scope));\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  const n =def.params.length;\n  let pdef;\n\n  // loop over defs to find matching key\n  for (let i = 0; i < n; ++i) {\n    pdef = def.params[i];\n    for (const k in pdef.key) {\n      if (pdef.key[k] !== value[k]) { pdef = null; break; }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value));\n\n  // parse params, create Params transform, return ref\n  const params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n}\n\n// -- Utilities -----\n\nexport const outerExpr = _ => _ && _.expr;\n\nexport const outerField = _ => _ && _.field;\n\nexport const isData = _ => _ === 'data';\n\nexport const isExpr = _ => _ === 'expr';\n\nexport const isField = _ => _ === 'field';\n\nexport const isCompare = _ => _ === 'compare';\n","import parseTransform from '../transform';\nimport {Collect} from '../../transforms';\nimport {ref} from '../../util';\nimport {array, error, extend} from 'vega-util';\n\nexport default function(from, group, scope) {\n  let facet, key, op, dataRef, parent;\n\n  // if no source data, generate singleton datum\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  }\n\n  // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.');\n\n    // use pre-faceted source data, if available\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type:    'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  }\n\n  // if not yet defined, get source data reference\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nexport function getDataRef(from, scope) {\n  return from.$ref ? from\n    : from.data && from.data.$ref ? from.data\n    : ref(scope.getData(from.data).output);\n}","import {Aggregate, Collect} from './transforms';\nimport {aggrField, entry, keyFieldRef, ref, sortKey} from './util';\nimport {isString} from 'vega-util';\n\nexport default function DataScope(scope, input, output, values, aggr) {\n  this.scope = scope;   // parent scope object\n  this.input = input;   // first operator in pipeline (tuple input)\n  this.output = output; // last operator in pipeline (tuple output)\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n\n  // last aggregate in transform pipeline\n  this.aggregate = aggr;\n\n  // lookup table of field indices\n  this.index = {};\n}\n\nDataScope.fromEntries = function(scope, entries) {\n  const n = entries.length,\n        values = entries[n-1],\n        output = entries[n-2];\n\n  let input = entries[0],\n      aggr = null,\n      i = 1;\n\n  if (input && input.type === 'load') {\n    input = entries[1];\n  }\n\n  // add operator entries to this scope, wire up pulse chain\n  scope.add(entries[0]);\n  for (; i<n; ++i) {\n    entries[i].params.pulse = ref(entries[i-1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  const as = aggrField(sort.op, sort.field);\n  let s;\n\n  if (p.ops) {\n    for (let i = 0, n = p.as.length; i < n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s=sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  const cache = ds[name] || (ds[name] = {}),\n        sort = sortKey(counts);\n\n  let k = fieldKey(field),\n      v, op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    const params = counts\n      ? {field: keyFieldRef, pulse: ds.countsRef(scope, field, counts)}\n      : {field: scope.fieldRef(field), pulse: ref(ds.output)};\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\n\nDataScope.prototype = {\n  countsRef(scope, field, sort) {\n    const ds = this,\n          cache = ds.counts || (ds.counts = {}),\n          k = fieldKey(field);\n\n    let v, a, p;\n\n    if (k != null) {\n      scope = ds.scope;\n      v = cache[k];\n    }\n\n    if (!v) {\n      p = {\n        groupby: scope.fieldRef(field, 'key'),\n        pulse: ref(ds.output)\n      };\n      if (sort && sort.field) addSortField(scope, p, sort);\n      a = scope.add(Aggregate(p));\n      v = scope.add(Collect({pulse: ref(a)}));\n      v = {agg: a, ref: ref(v)};\n      if (k != null) cache[k] = v;\n    } else if (sort && sort.field) {\n      addSortField(scope, v.agg.params, sort);\n    }\n\n    return v.ref;\n  },\n\n  tuplesRef() {\n    return ref(this.values);\n  },\n\n  extentRef(scope, field) {\n    return cache(scope, this, 'extent', 'extent', field, false);\n  },\n\n  domainRef(scope, field) {\n    return cache(scope, this, 'domain', 'values', field, false);\n  },\n\n  valuesRef(scope, field, sort) {\n    return cache(scope, this, 'vals', 'values', field, sort || true);\n  },\n\n  lookupRef(scope, field) {\n    return cache(scope, this, 'lookup', 'tupleindex', field, false);\n  },\n\n  indataRef(scope, field) {\n    return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n  }\n};\n","import {operator} from '../util';\nimport {parseExpression} from 'vega-functions';\n\nexport default function(spec, scope, name) {\n  const remove = spec.remove,\n        insert = spec.insert,\n        toggle = spec.toggle,\n        modify = spec.modify,\n        values = spec.values,\n        op = scope.add(operator());\n\n  const update = 'if(' + spec.trigger + ',modify(\"'\n    + name + '\",'\n    + [insert, remove, toggle, modify, values]\n        .map(_ => _ == null ? 'null' : _)\n        .join(',')\n    + '),0)';\n\n  const expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n","import parseEncode from './encode';\nimport clip from './marks/clip';\nimport definition from './marks/definition';\nimport interactive from './marks/interactive';\nimport parseData from './marks/data';\nimport parseFacet from './marks/facet';\nimport parseSubflow from './marks/subflow';\nimport getRole from './marks/role';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole, MarkRole, ScopeRole} from './marks/roles';\nimport parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport DataScope from '../DataScope';\nimport {fieldRef, isSignal, ref} from '../util';\nimport {error} from 'vega-util';\nimport {Bound, Collect, DataJoin, Encode, Mark, Overlap, Render, Sieve, SortItems, ViewLayout} from '../transforms';\n\nexport default function(spec, scope) {\n  const role = getRole(spec),\n        group = spec.type === GroupMark,\n        facet = spec.from && spec.from.facet,\n        overlap = spec.overlap;\n\n  let layout = spec.layout || role === ScopeRole || role === FrameRole,\n      ops, op, store, enc, name, layoutRef, boundRef;\n\n  const nested = role === MarkRole || layout || facet;\n\n  // resolve input data\n  const input = parseData(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add(DataJoin({\n    key:   input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  const joinRef = ref(op);\n\n  // collect visual items\n  op = store = scope.add(Collect({pulse: joinRef}));\n\n  // connect visual items to scenegraph\n  op = scope.add(Mark({\n    markdef:     definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip:        clip(spec.clip, scope),\n    context:     {$context: true},\n    groups:      scope.lookup(),\n    parent:      scope.signals.parent ? scope.signalRef('parent') : null,\n    index:       scope.markpath(),\n    pulse:       ref(op)\n  }));\n  const markRef = ref(op);\n\n  // add visual encoders\n  op = enc = scope.add(Encode(parseEncode(\n    spec.encode, spec.type, role, spec.style, scope,\n    {mod: false, pulse: markRef}\n  )));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(_ => {\n      const tx = parseTransform(_, scope),\n            md = tx.metadata;\n      if (md.generates || md.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      if (!md.nomod) enc.params.mod = true; // update encode mod handling\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort:  scope.compareRef(spec.sort),\n      pulse: ref(op)\n    }));\n  }\n\n  const encodeRef = ref(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout:   scope.objectProperty(spec.layout),\n      legends:  scope.legends,\n      mark:     markRef,\n      pulse:    encodeRef\n    }));\n    layoutRef = ref(layout);\n  }\n\n  // compute bounding boxes\n  const bound = scope.add(Bound({mark: markRef, pulse: layoutRef || encodeRef}));\n  boundRef = ref(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) { ops = scope.operators; ops.pop(); if (layout) ops.pop(); }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input)          // explicit facet\n        : nested ? parseSubflow(spec, scope, input) // standard mark group\n        : scope.parse(spec); // guide group, we can avoid nested scopes\n    scope.popState();\n\n    if (nested) { if (layout) ops.push(layout); ops.push(bound); }\n  }\n\n  // if requested, add overlap removal transform\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  }\n\n  // render / sieve items\n  const render = scope.add(Render({pulse: boundRef})),\n        sieve = scope.add(Sieve({pulse: ref(render)}, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(on => {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  const method = overlap.method,\n        bound = overlap.bound,\n        sep = overlap.separation;\n\n  const params = {\n    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse:  source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({field: overlap.order});\n  }\n\n  if (bound) {\n    const tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n","import {getDataRef} from './data';\nimport DataScope from '../../DataScope';\nimport {Collect, Facet, PreFacet, Sieve} from '../../transforms';\nimport {ref} from '../../util';\nimport {error, stringValue} from 'vega-util';\n\nexport default function(spec, scope, group) {\n  const facet = spec.from.facet,\n        name = facet.name,\n        data = getDataRef(facet, scope);\n  let op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key:   scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  }\n\n  // initialize facet subscope\n  const subscope = scope.fork(),\n        source = subscope.add(Collect()),\n        values = subscope.add(Sieve({pulse: ref(source)}));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null);\n\n  // parse faceted subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n","import {PreFacet, Sieve} from '../../transforms';\n\nexport default function(spec, scope, input) {\n  const op = scope.add(PreFacet({pulse: input.pulse})),\n        subscope = scope.fork();\n\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null);\n\n  // parse group mark subflow\n  op.params.subflow = {\n    $subflow: subscope.parse(spec).toRuntime()\n  };\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport {\n  Discrete, Gradient,\n  GuideLabelStyle, LegendScales, Skip, Symbols\n} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport {getEncoding, getStyle, lookup} from './guides/guide-util';\nimport legendGradient from './guides/legend-gradient';\nimport legendGradientDiscrete from './guides/legend-gradient-discrete';\nimport legendGradientLabels from './guides/legend-gradient-labels';\nimport legendSymbolGroups, {legendSymbolLayout} from './guides/legend-symbol-groups';\nimport legendTitle from './guides/legend-title';\nimport parseMark from './mark';\nimport {LegendEntryRole, LegendRole} from './marks/roles';\n\nimport {deref, ref} from '../util';\nimport {Collect, LegendEntries} from '../transforms';\n\nimport {parseExpression} from 'vega-functions';\nimport {isContinuous, isDiscretizing} from 'vega-scale';\nimport {error} from 'vega-util';\n\nexport default function(spec, scope) {\n  const config = scope.config.legend,\n        encode = spec.encode || {},\n        _ = lookup(spec, config),\n        legendEncode = encode.legend || {},\n        name = legendEncode.name || undefined,\n        interactive = legendEncode.interactive,\n        style = legendEncode.style,\n        scales = {};\n\n  let scale = 0, entryLayout, params, children;\n\n  // resolve scales and 'canonical' scale name\n  LegendScales.forEach(s => spec[s]\n    ? (scales[s] = spec[s], scale = scale || spec[s]) : 0\n  );\n  if (!scale) error('Missing valid scale for legend.');\n\n  // resolve legend type (symbol, gradient, or discrete gradient)\n  const type = legendType(spec, scope.scaleType(scale));\n\n  // single-element data source for legend group\n  const datum = {\n    title:  spec.title != null,\n    scales: scales,\n    type:   type,\n    vgrad:  type !== 'symbol' &&  _.isVertical()\n  };\n  const dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // encoding properties for legend entry sub-group\n  const entryEncode = {enter: {x: {value: 0}, y: {value: 0}}};\n\n  // data source for legend values\n  const entryRef = ref(scope.add(LegendEntries(params = {\n    type:    type,\n    scale:   scope.scaleRef(scale),\n    count:   scope.objectProperty(_('tickCount')),\n    limit:   scope.property(_('symbolLimit')),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // continuous gradient legend\n  if (type === Gradient) {\n    children = [\n      legendGradient(spec, scale, config, encode.gradient),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n    // adjust default tick count based on the gradient length\n    params.count = params.count || scope.signalRef(\n      `max(2,2*floor((${deref(_.gradientLength())})/100))`\n    );\n  }\n\n  // discrete gradient legend\n  else if (type === Discrete) {\n    children = [\n      legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n  }\n\n  // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [\n      legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))\n    ];\n    // pass symbol size information to legend entry generator\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  }\n\n  // generate legend marks\n  children = [\n    guideGroup({\n      role: LegendEntryRole,\n      from: dataRef,\n      encode: entryEncode,\n      marks: children,\n      layout: entryLayout,\n      interactive\n    })\n  ];\n\n  // include legend title if defined\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse legend specification\n  return parseMark(\n    guideGroup({\n      role:        LegendRole,\n      from:        dataRef,\n      encode:      extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\nfunction legendType(spec, scaleType) {\n  let type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient\n      : isDiscretizing(scaleType) ? Discrete\n      : Symbols;\n  }\n\n  return type !== Gradient ? type\n    : isDiscretizing(scaleType) ? Discrete\n    : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);\n}\n\nfunction buildLegendEncode(_, spec, config) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset'),\n    padding:      _('padding'),\n    titlePadding: _('titlePadding'),\n    cornerRadius: _('cornerRadius'),\n    fill:         _('fillColor'),\n    stroke:       _('strokeColor'),\n    strokeWidth:  config.strokeWidth,\n    strokeDash:   config.strokeDash,\n    x:            _('legendX'),\n    y:            _('legendY'),\n\n    // accessibility support\n    format:       spec.format,\n    formatType:   spec.formatType\n  });\n\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  const size = deref(getChannel('size', spec, marks)),\n        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),\n        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));\n\n  return parseExpression(\n    `max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`,\n    scope\n  );\n}\n\nfunction getChannel(name, spec, marks) {\n  return spec[name]\n    ? `scale(\"${spec[name]}\",datum)`\n    : getEncoding(name, marks[0].encode);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport {GroupSubtitleStyle, GroupTitleStyle, Left, Right, Skip} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport guideMark from './guides/guide-mark';\nimport {alignExpr, lookup} from './guides/guide-util';\nimport parseMark from './mark';\nimport {TextMark} from './marks/marktypes';\nimport {TitleRole, TitleSubtitleRole, TitleTextRole} from './marks/roles';\nimport {Collect} from '../transforms';\nimport {ref} from '../util';\nimport {extend, isString} from 'vega-util';\n\nconst angleExpr = `item.orient===\"${Left}\"?-90:item.orient===\"${Right}\"?90:0`;\n\nexport default function(spec, scope) {\n  spec = isString(spec) ? {text: spec} : spec;\n\n  const _ = lookup(spec, scope.config.title),\n        encode = spec.encode || {},\n        userEncode = encode.group || {},\n        name = userEncode.name || undefined,\n        interactive = userEncode.interactive,\n        style = userEncode.style,\n        children = [];\n\n  // single-element data source for group title\n  const datum = {},\n        dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // include title text\n  children.push(buildTitle(spec, _, titleEncode(spec), dataRef));\n\n  // include subtitle text\n  if (spec.subtitle) {\n    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));\n  }\n\n  // parse title specification\n  return parseMark(\n    guideGroup({\n      role:        TitleRole,\n      from:        dataRef,\n      encode:      groupEncode(_, userEncode),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\n// provide backwards-compatibility for title custom encode;\n// the top-level encode block has been *deprecated*.\nfunction titleEncode(spec) {\n  const encode = spec.encode;\n  return (encode && encode.title) || extend({\n    name: spec.name,\n    interactive: spec.interactive,\n    style: spec.style\n  }, encode);\n}\n\nfunction groupEncode(_, userEncode) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:      _('orient'),\n    anchor:      _('anchor'),\n    align:       {signal: alignExpr},\n    angle:       {signal: angleExpr},\n    limit:       _('limit'),\n    frame:       _('frame'),\n    offset:      _('offset') || 0,\n    padding:     _('subtitlePadding')\n  });\n\n  return extendEncode(encode, userEncode, Skip);\n}\n\nfunction buildTitle(spec, _, userEncode, dataRef) {\n  const zero = {value: 0},\n        text = spec.text,\n        encode = {\n          enter: {opacity: zero},\n          update: {opacity: {value: 1}},\n          exit: {opacity: zero}\n        };\n\n  addEncoders(encode, {\n    text:       text,\n    align:      {signal: 'item.mark.group.align'},\n    angle:      {signal: 'item.mark.group.angle'},\n    limit:      {signal: 'item.mark.group.limit'},\n    baseline:   'top',\n    dx:         _('dx'),\n    dy:         _('dy'),\n    fill:       _('color'),\n    font:       _('font'),\n    fontSize:   _('fontSize'),\n    fontStyle:  _('fontStyle'),\n    fontWeight: _('fontWeight'),\n    lineHeight: _('lineHeight')\n  }, { // update\n    align:      _('align'),\n    angle:      _('angle'),\n    baseline:   _('baseline')\n  });\n\n  return guideMark({\n    type: TextMark,\n    role: TitleTextRole,\n    style: GroupTitleStyle,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction buildSubTitle(spec, _, userEncode, dataRef) {\n  const zero = {value: 0},\n        text = spec.subtitle,\n        encode = {\n          enter: {opacity: zero},\n          update: {opacity: {value: 1}},\n          exit: {opacity: zero}\n        };\n\n  addEncoders(encode, {\n    text:       text,\n    align:      {signal: 'item.mark.group.align'},\n    angle:      {signal: 'item.mark.group.angle'},\n    limit:      {signal: 'item.mark.group.limit'},\n    baseline:   'top',\n    dx:         _('dx'),\n    dy:         _('dy'),\n    fill:       _('subtitleColor'),\n    font:       _('subtitleFont'),\n    fontSize:   _('subtitleFontSize'),\n    fontStyle:  _('subtitleFontStyle'),\n    fontWeight: _('subtitleFontWeight'),\n    lineHeight: _('subtitleLineHeight')\n  }, { // update\n    align:      _('align'),\n    angle:      _('angle'),\n    baseline:   _('baseline')\n  });\n\n  return guideMark({\n    type:  TextMark,\n    role:  TitleSubtitleRole,\n    style: GroupSubtitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n","import parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport {Collect, Load, Relay, Sieve} from '../transforms';\nimport {hasSignal, isSignal, ref} from '../util';\nimport {array} from 'vega-util';\n\nexport default function parseData(data, scope) {\n  const transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(tx => {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(on => {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  const output = [];\n  let source = null,\n      modify = false,\n      generate = false,\n      upstream, i, n, t, m;\n\n  if (data.values) {\n    // hard-wired input data set\n    if (isSignal(data.values) || hasSignal(data.format)) {\n      // if either values is signal or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, ingest upon dataflow init\n      output.push(source = collect({\n        $ingest: data.values,\n        $format: data.format\n      }));\n    }\n  } else if (data.url) {\n    // load data from external source\n    if (hasSignal(data.url) || hasSignal(data.format)) {\n      // if either url or format has signal, use dynamic loader\n      output.push(load(scope, data));\n      output.push(source = collect());\n    } else {\n      // otherwise, request load upon dataflow init\n      output.push(source = collect({\n        $request: data.url,\n        $format: data.format\n      }));\n    }\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source)\n      .map(d => ref(scope.getData(d).output));\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i=0, n=ops.length; i<n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n\n    if (m.source) source = t;\n    else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  const s = Collect({}, values);\n  s.metadata = {source: true};\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url:    data.url ? scope.property(data.url) : undefined,\n    async:  data.async ? scope.property(data.async) : undefined,\n    values: data.values ? scope.property(data.values) : undefined,\n    format: scope.objectProperty(data.format)\n  });\n}\n","import {extend, stringValue} from 'vega-util';\nimport {Bottom, Left, Right, Top} from './constants';\nimport {encoder} from '../encode/util';\nimport {isSignal} from '../../util';\n\nconst isX = orient => orient === Bottom || orient === Top;\n\n// get sign coefficient based on axis orient\nexport const getSign = (orient, a, b) => isSignal(orient)\n  ? ifLeftTopExpr(orient.signal, a, b)\n  : orient === Left || orient === Top ? a : b;\n\n// condition on axis x-direction\nexport const ifX = (orient, a, b) => isSignal(orient)\n  ? ifXEnc(orient.signal, a, b)\n  : isX(orient) ? a : b;\n\n// condition on axis y-direction\nexport const ifY = (orient, a, b) => isSignal(orient)\n  ? ifYEnc(orient.signal, a, b)\n  : isX(orient) ? b : a;\n\nexport const ifTop = (orient, a, b) => isSignal(orient)\n  ? ifTopExpr(orient.signal, a, b)\n  : orient === Top ? {value: a} : {value: b};\n\nexport const ifRight = (orient, a, b) => isSignal(orient)\n  ? ifRightExpr(orient.signal, a, b)\n  : orient === Right ? {value: a} : {value: b};\n\nconst ifXEnc = ($orient, a, b) => ifEnc(\n  `${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b\n);\n\nconst ifYEnc = ($orient, a, b) => ifEnc(\n  `${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b\n);\n\nconst ifLeftTopExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b\n);\n\nconst ifTopExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Top}'`, a, b\n);\n\nconst ifRightExpr = ($orient, a, b) => ifExpr(\n  `${$orient} === '${Right}'`, a, b\n);\n\nconst ifEnc = (test, a, b) => {\n  // ensure inputs are encoder objects (or null)\n  a = a != null ? encoder(a) : a;\n  b = b != null ? encoder(b) : b;\n\n  if (isSimple(a) && isSimple(b)) {\n    // if possible generate simple signal expression\n    a = a ? (a.signal || stringValue(a.value)) : null;\n    b = b ? (b.signal || stringValue(b.value)) : null;\n    return {signal: `${test} ? (${a}) : (${b})`};\n  } else {\n    // otherwise generate rule set\n    return [extend({test}, a)].concat(b || []);\n  }\n};\n\nconst isSimple = enc => (\n  enc == null || Object.keys(enc).length === 1\n);\n\nconst ifExpr = (test, a, b) => ({\n  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`\n});\n\nexport const ifOrient = ($orient, t, b, l, r) => ({\n  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '')\n        + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '')\n        + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '')\n        + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '')\n        + '(null)'\n});\n\nconst toExpr = v => isSignal(v)\n  ? v.signal\n  : v == null ? null : stringValue(v);\n\nexport const mult = (sign, value) => value === 0 ? 0 : isSignal(sign)\n  ? {signal: `(${sign.signal}) * ${value}`}\n  : {value: sign * value};\n\nexport const patch = (value, base) => {\n  const s = value.signal;\n  return s && s.endsWith('(null)')\n    ? {signal: s.slice(0, -6) + base.signal}\n    : value;\n};\n","import {ifOrient, ifX} from './axis-util';\nimport {Bottom, GuideLabelStyle, GuideTitleStyle, Top} from './constants';\nimport {isSignal} from '../../util';\nimport {extend, hasOwnProperty} from 'vega-util';\n\nfunction fallback(prop, config, axisConfig, style) {\n  let styleProp;\n\n  if (config && hasOwnProperty(config, prop)) {\n    return config[prop];\n  }\n  else if (hasOwnProperty(axisConfig, prop)) {\n    return axisConfig[prop];\n  }\n  else if (prop.startsWith('title')) {\n    switch (prop) {\n      case 'titleColor':\n        styleProp = 'fill';\n        break;\n      case 'titleFont':\n      case 'titleFontSize':\n      case 'titleFontWeight':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideTitleStyle][styleProp];\n  }\n  else if (prop.startsWith('label')) {\n    switch (prop) {\n      case 'labelColor':\n        styleProp = 'fill';\n        break;\n      case 'labelFont':\n      case 'labelFontSize':\n        styleProp = prop[5].toLowerCase() + prop.slice(6);\n    }\n    return style[GuideLabelStyle][styleProp];\n  }\n\n  return null;\n}\n\nfunction keys(objects) {\n  const map = {};\n  for (const obj of objects) {\n    if (!obj) continue;\n    for (const key in obj) map[key] = 1;\n  }\n  return Object.keys(map);\n}\n\nexport default function(spec, scope) {\n  var config = scope.config,\n      style = config.style,\n      axis = config.axis,\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,\n      orient = spec.orient,\n      xy, or, key;\n\n  if (isSignal(orient)) {\n    const xyKeys = keys([\n            config.axisX, config.axisY\n          ]),\n          orientKeys = keys([\n            config.axisTop, config.axisBottom,\n            config.axisLeft, config.axisRight\n          ]);\n\n    xy = {};\n    for (key of xyKeys) {\n      xy[key] = ifX(\n        orient,\n        fallback(key, config.axisX, axis, style),\n        fallback(key, config.axisY, axis, style)\n      );\n    }\n\n    or = {};\n    for (key of orientKeys) {\n      or[key] = ifOrient(\n        orient.signal,\n        fallback(key, config.axisTop, axis, style),\n        fallback(key, config.axisBottom, axis, style),\n        fallback(key, config.axisLeft, axis, style),\n        fallback(key, config.axisRight, axis, style)\n      );\n    }\n  } else {\n    xy = (orient === Top || orient === Bottom) ? config.axisX : config.axisY;\n    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];\n  }\n\n  const result = (xy || or || band)\n    ? extend({}, axis, xy, or, band)\n    : axis;\n\n  return result;\n}\n","import {ifX, ifY} from './axis-util';\nimport {one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisDomainRole} from '../marks/roles';\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient;\n\n  let enter, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('domainColor'),\n    strokeCap:        _('domainCap'),\n    strokeDash:       _('domainDash'),\n    strokeDashOffset: _('domainDashOffset'),\n    strokeWidth:      _('domainWidth'),\n    strokeOpacity:    _('domainOpacity')\n  });\n\n  const pos0 = position(spec, 0);\n  const pos1 = position(spec, 1);\n\n  enter.x = update.x = ifX(orient, pos0, zero);\n  enter.x2 = update.x2 = ifX(orient, pos1);\n\n  enter.y = update.y = ifY(orient, pos0, zero);\n  enter.y2 = update.y2 = ifY(orient, pos1);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisDomainRole,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {scale: spec.scale, range: pos};\n}\n","import {getSign, ifX, ifY} from './axis-util';\nimport {Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisGridRole} from '../marks/roles';\nimport {isSignal} from '../../util';\nimport {extend, isObject} from 'vega-util';\n\nexport default function(spec, config, userEncode, dataRef, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        vscale = spec.gridScale,\n        sign = getSign(orient, 1, -1),\n        offset = offsetValue(spec.offset, sign);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: exit = {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('gridColor'),\n    strokeCap:        _('gridCap'),\n    strokeDash:       _('gridDash'),\n    strokeDashOffset: _('gridDashOffset'),\n    strokeOpacity:    _('gridOpacity'),\n    strokeWidth:      _('gridWidth')\n  });\n\n  const tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   band.band,\n    extra:  band.extra,\n    offset: band.offset,\n    round:  _('tickRound')\n  };\n\n  const sz = ifX(orient, {signal: 'height'}, {signal: 'width'});\n\n  const gridStart = vscale\n    ? {scale: vscale, range: 0, mult: sign, offset: offset}\n    : {value: 0, offset: offset};\n\n  const gridEnd = vscale\n    ? {scale: vscale, range: 1, mult: sign, offset: offset}\n    : extend(sz, {mult: sign, offset: offset});\n\n  enter.x = update.x = ifX(orient, tickPos, gridStart);\n  enter.y = update.y = ifY(orient, tickPos, gridStart);\n  enter.x2 = update.x2 = ifY(orient, gridEnd);\n  enter.y2 = update.y2 = ifX(orient, gridEnd);\n  exit.x = ifX(orient, tickPos);\n  exit.y = ifY(orient, tickPos);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisGridRole,\n    key:  Value,\n    from: dataRef,\n    encode\n   }, userEncode);\n}\n\nfunction offsetValue(offset, sign)  {\n  if (sign === 1) {\n    // no further adjustment needed, just return offset\n  } else if (!isObject(offset)) {\n    offset = isSignal(sign)\n      ? {signal: `(${sign.signal}) * (${offset || 0})`}\n      : sign * (offset || 0);\n  } else {\n    let entry = offset = extend({}, offset);\n    while (entry.mult != null) {\n      if (!isObject(entry.mult)) {\n        entry.mult = isSignal(sign) // no offset if sign === 1\n          ? {signal: `(${entry.mult}) * (${sign.signal})`}\n          : entry.mult * sign;\n        return offset;\n      } else {\n        entry = entry.mult = extend({}, entry.mult);\n      }\n    }\n    entry.mult = sign;\n  }\n\n  return offset;\n}\n","import {getSign, ifRight, ifTop, ifX, ifY, patch} from './axis-util';\nimport {GuideLabelStyle, Label, Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {extendOffset, lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisLabelRole} from '../marks/roles';\nimport {deref} from '../../util';\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), '\n      + 'scale(\"' + scale + '\", datum.value), '\n      + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        scale = spec.scale,\n        sign = getSign(orient, -1, 1),\n        flush = deref(_('labelFlush')),\n        flushOffset = deref(_('labelFlushOffset')),\n        labelAlign = _('labelAlign'),\n        labelBaseline = _('labelBaseline');\n\n  let flushOn = flush === 0 || !!flush,\n      update;\n\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(_('labelPadding') || 0);\n  tickSize.offset.mult = sign;\n\n  const tickPos = {\n    scale:  scale,\n    field:  Value,\n    band:   0.5,\n    offset: extendOffset(band.offset, _('labelOffset'))\n  };\n\n  const align = ifX(orient,\n    flushOn\n      ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"')\n      : {value: 'center'},\n    ifRight(orient, 'left', 'right')\n  );\n\n  const baseline = ifX(orient,\n    ifTop(orient, 'bottom', 'top'),\n    flushOn\n      ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"')\n      : {value: 'middle'}\n  );\n\n  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);\n  flushOn = flushOn && flushOffset;\n\n  const enter = {\n    opacity: zero,\n    x: ifX(orient, tickPos, tickSize),\n    y: ifY(orient, tickPos, tickSize)\n  };\n\n  const encode = {\n    enter: enter,\n    update: update = {\n      opacity: one,\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y,\n      align,\n      baseline\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n\n  addEncoders(encode, {\n    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,\n    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null\n  });\n\n  addEncoders(encode, {\n    angle:       _('labelAngle'),\n    fill:        _('labelColor'),\n    fillOpacity: _('labelOpacity'),\n    font:        _('labelFont'),\n    fontSize:    _('labelFontSize'),\n    fontWeight:  _('labelFontWeight'),\n    fontStyle:   _('labelFontStyle'),\n    limit:       _('labelLimit'),\n    lineHeight:  _('labelLineHeight')\n  }, {\n    align:       labelAlign,\n    baseline:    labelBaseline\n  });\n\n  const bound   = _('labelBound');\n  let overlap = _('labelOverlap');\n\n  // if overlap method or bound defined, request label overlap removal\n  overlap = overlap || bound ? {\n    separation: _('labelSeparation'),\n    method: overlap,\n    order: 'datum.index',\n    bound: bound ? {scale, orient, tolerance: bound} : null\n  } : undefined;\n\n  if (update.align !== align) {\n    update.align = patch(update.align, align);\n  }\n  if (update.baseline !== baseline) {\n    update.baseline = patch(update.baseline, baseline);\n  }\n\n  return guideMark({\n    type:  TextMark,\n    role:  AxisLabelRole,\n    style: GuideLabelStyle,\n    key:   Value,\n    from:  dataRef,\n    encode,\n    overlap\n  }, userEncode);\n}\n","import {getSign, ifTop, ifX, ifY, mult, patch} from './axis-util';\nimport {Bottom, GuideTitleStyle, Top, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {alignExpr, anchorExpr, lookup} from './guide-util';\nimport {addEncoders, encoder, has} from '../encode/util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisTitleRole} from '../marks/roles';\nimport {extend} from 'vega-util';\n\nexport default function(spec, config, userEncode, dataRef) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, update;\n  const encode = {\n    enter: enter = {\n      opacity: zero,\n      anchor: encoder(_('titleAnchor', null)),\n      align: {signal: alignExpr}\n    },\n    update: update = extend({}, enter, {\n      opacity: one,\n      text: encoder(spec.title)\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n\n  const titlePos = {\n    signal: `lerp(range(\"${spec.scale}\"), ${anchorExpr(0, 1, 0.5)})`\n  };\n\n  update.x = ifX(orient, titlePos);\n  update.y = ifY(orient, titlePos);\n  enter.angle = ifX(orient, zero, mult(sign, 90));\n  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {value: Bottom});\n  update.angle = enter.angle;\n  update.baseline = enter.baseline;\n\n  addEncoders(encode, {\n    fill:        _('titleColor'),\n    fillOpacity: _('titleOpacity'),\n    font:        _('titleFont'),\n    fontSize:    _('titleFontSize'),\n    fontStyle:   _('titleFontStyle'),\n    fontWeight:  _('titleFontWeight'),\n    limit:       _('titleLimit'),\n    lineHeight:  _('titleLineHeight')\n  }, { // require update\n    align:       _('titleAlign'),\n    angle:       _('titleAngle'),\n    baseline:    _('titleBaseline')\n  });\n\n  autoLayout(_, orient, encode, userEncode);\n  encode.update.align = patch(encode.update.align, enter.align);\n  encode.update.angle = patch(encode.update.angle, enter.angle);\n  encode.update.baseline = patch(encode.update.baseline, enter.baseline);\n\n  return guideMark({\n    type:  TextMark,\n    role:  AxisTitleRole,\n    style: GuideTitleStyle,\n    from:  dataRef,\n    encode\n  }, userEncode);\n}\n\nfunction autoLayout(_, orient, encode, userEncode) {\n  const auto = (value, dim) => value != null\n    ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false)\n    : !has(dim, userEncode) ? true : false;\n\n  const autoY = auto(_('titleX'), 'x'),\n        autoX = auto(_('titleY'), 'y');\n\n  encode.enter.auto = autoX === autoY\n    ? encoder(autoX)\n    : ifX(orient, encoder(autoX), encoder(autoY));\n}\n","import {addEncoders, extendEncode} from './encode/util';\nimport axisConfig from './guides/axis-config';\nimport axisDomain from './guides/axis-domain';\nimport axisGrid from './guides/axis-grid';\nimport axisTicks from './guides/axis-ticks';\nimport axisLabels from './guides/axis-labels';\nimport axisTitle from './guides/axis-title';\nimport {Skip} from './guides/constants';\nimport guideGroup from './guides/guide-group';\nimport {lookup, tickBand} from './guides/guide-util';\nimport {AxisRole} from './marks/roles';\nimport parseMark from './mark';\nimport {AxisTicks, Collect} from '../transforms';\nimport {ref, value} from '../util';\n\nexport default function(spec, scope) {\n  const config = axisConfig(spec, scope),\n        encode = spec.encode || {},\n        axisEncode = encode.axis || {},\n        name = axisEncode.name || undefined,\n        interactive = axisEncode.interactive,\n        style = axisEncode.style,\n        _ = lookup(spec, config),\n        band = tickBand(_);\n\n  // single-element data source for axis group\n  const datum = {\n    scale:  spec.scale,\n    ticks:  !!_('ticks'),\n    labels: !!_('labels'),\n    grid:   !!_('grid'),\n    domain: !!_('domain'),\n    title:  spec.title != null\n  };\n  const dataRef = ref(scope.add(Collect({}, [datum])));\n\n  // data source for axis ticks\n  const ticksRef = ref(scope.add(AxisTicks({\n    scale:   scope.scaleRef(spec.scale),\n    extra:   scope.property(band.extra),\n    count:   scope.objectProperty(spec.tickCount),\n    values:  scope.objectProperty(spec.values),\n    minstep: scope.property(spec.tickMinStep),\n    formatType: scope.property(spec.formatType),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // generate axis marks\n  const children = [];\n  let size;\n\n  // include axis gridlines if requested\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));\n  }\n\n  // include axis ticks if requested\n  if (datum.ticks) {\n    size = _('tickSize');\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));\n  }\n\n  // include axis labels if requested\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));\n  }\n\n  // include axis domain path if requested\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  }\n\n  // include axis title if defined\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  }\n\n  // parse axis specification\n  return parseMark(\n    guideGroup({\n      role:        AxisRole,\n      from:        dataRef,\n      encode:      extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),\n      marks:       children,\n      aria:        _('aria'),\n      description: _('description'),\n      zindex:      _('zindex'),\n      name,\n      interactive,\n      style\n    }),\n    scope\n  );\n}\n\nfunction buildAxisEncode(_, spec) {\n  const encode = {enter: {}, update: {}};\n\n  addEncoders(encode, {\n    orient:       _('orient'),\n    offset:       _('offset') || 0,\n    position:     value(spec.position, 0),\n    titlePadding: _('titlePadding'),\n    minExtent:    _('minExtent'),\n    maxExtent:    _('maxExtent'),\n    range:        {signal: `abs(span(range(\"${spec.scale}\")))`},\n    translate:    _('translate'),\n\n    // accessibility support\n    format:       spec.format,\n    formatType:   spec.formatType\n  });\n\n  return encode;\n}\n","import {getSign, ifX, ifY} from './axis-util';\nimport {Value, one, zero} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {addEncoders, encoder} from '../encode/util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisTickRole} from '../marks/roles';\n\nexport default function(spec, config, userEncode, dataRef, size, band) {\n  const _ = lookup(spec, config),\n        orient = spec.orient,\n        sign = getSign(orient, -1, 1);\n\n  let enter, exit, update;\n  const encode = {\n    enter: enter = {opacity: zero},\n    update: update = {opacity: one},\n    exit: exit = {opacity: zero}\n  };\n\n  addEncoders(encode, {\n    stroke:           _('tickColor'),\n    strokeCap:        _('tickCap'),\n    strokeDash:       _('tickDash'),\n    strokeDashOffset: _('tickDashOffset'),\n    strokeOpacity:    _('tickOpacity'),\n    strokeWidth:      _('tickWidth')\n  });\n\n  const tickSize = encoder(size);\n  tickSize.mult = sign;\n\n  const tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   band.band,\n    extra:  band.extra,\n    offset: band.offset,\n    round:  _('tickRound')\n  };\n\n  update.y = enter.y = ifX(orient, zero, tickPos);\n  update.y2 = enter.y2 = ifX(orient, tickSize);\n  exit.x = ifX(orient, tickPos);\n\n  update.x = enter.x = ifY(orient, zero, tickPos);\n  update.x2 = enter.x2 = ifY(orient, tickSize);\n  exit.y = ifY(orient, tickPos);\n\n  return guideMark({\n    type: RuleMark,\n    role: AxisTickRole,\n    key:  Value,\n    from: dataRef,\n    encode\n  }, userEncode);\n}\n","import parseSignalUpdates from './signal-updates';\nimport {initScale, parseScale} from './scale';\nimport parseProjection from './projection';\nimport parseLegend from './legend';\nimport parseSignal from './signal';\nimport parseTitle from './title';\nimport parseData from './data';\nimport parseMark from './mark';\nimport parseAxis from './axis';\nimport {array} from 'vega-util';\n\nexport default function(spec, scope, preprocessed) {\n  const signals = array(spec.signals),\n        scales = array(spec.scales);\n\n  // parse signal definitions, if not already preprocessed\n  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));\n\n  // parse cartographic projection definitions\n  array(spec.projections).forEach(_ => parseProjection(_, scope));\n\n  // initialize scale references\n  scales.forEach(_ => initScale(_, scope));\n\n  // parse data sources\n  array(spec.data).forEach(_ => parseData(_, scope));\n\n  // parse scale definitions\n  scales.forEach(_ => parseScale(_, scope));\n\n  // parse signal updates\n  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));\n\n  // parse axis definitions\n  array(spec.axes).forEach(_ => parseAxis(_, scope));\n\n  // parse mark definitions\n  array(spec.marks).forEach(_ => parseMark(_, scope));\n\n  // parse legend definitions\n  array(spec.legends).forEach(_ => parseLegend(_, scope));\n\n  // parse title, if defined\n  if (spec.title) parseTitle(spec.title, scope);\n\n  // parse collected lambda (anonymous) expressions\n  scope.parseLambdas();\n\n  return scope;\n}\n","import parseAutosize from './autosize';\nimport parsePadding from './padding';\nimport parseEncode from './encode';\nimport parseSignal from './signal';\nimport parseSpec from './scope';\nimport {extendEncode} from './encode/util';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole} from './marks/roles';\nimport {operator, ref, value} from '../util';\nimport DataScope from '../DataScope';\nimport {Bound, Collect, Encode, Render, Sieve, ViewLayout} from '../transforms';\nimport {array, extend, hasOwnProperty} from 'vega-util';\n\nconst rootEncode = spec => extendEncode(\n  {\n    enter: {\n      x: {value: 0},\n      y: {value: 0}\n    },\n    update: {\n      width: {signal: 'width'},\n      height: {signal: 'height'}\n    }\n  },\n  spec\n);\n\nexport default function parseView(spec, scope) {\n  const config = scope.config;\n\n  // add scenegraph root\n  const root = ref(scope.root = scope.add(operator()));\n\n  // parse top-level signal definitions\n  const signals = collectSignals(spec, config);\n  signals.forEach(_ => parseSignal(_, scope));\n\n  // assign description, event, legend, and locale configuration\n  scope.description = spec.description || config.description;\n  scope.eventConfig = config.events;\n  scope.legends = scope.objectProperty(config.legend && config.legend.layout);\n  scope.locale = config.locale;\n\n  // store root group item\n  const input = scope.add(Collect());\n\n  // encode root group item\n  const encode = scope.add(Encode(parseEncode(\n    rootEncode(spec.encode), GroupMark, FrameRole,\n    spec.style, scope, {pulse: ref(input)}\n  )));\n\n  // perform view layout\n  const parent = scope.add(ViewLayout({\n    layout:   scope.objectProperty(spec.layout),\n    legends:  scope.legends,\n    autosize: scope.signalRef('autosize'),\n    mark:     root,\n    pulse:    ref(encode)\n  }));\n  scope.operators.pop();\n\n  // parse remainder of specification\n  scope.pushState(ref(encode), ref(parent), null);\n  parseSpec(spec, scope, signals);\n  scope.operators.push(parent);\n\n  // bound / render / sieve root item\n  let op = scope.add(Bound({mark: root, pulse: ref(parent)}));\n  op = scope.add(Render({pulse: ref(op)}));\n  op = scope.add(Sieve({pulse: ref(op)}));\n\n  // track metadata for root item\n  scope.addData('root', new DataScope(scope, input, input, op));\n\n  return scope;\n}\n\nfunction signalObject(name, value) {\n  return value && value.signal\n    ? { name, update: value.signal }\n    : { name, value };\n}\n\n/**\n * Collect top-level signals, merging values as needed. Signals\n * defined in the config signals arrays are added only if that\n * signal is not explicitly defined in the specification.\n * Built-in signals (autosize, background, padding, width, height)\n * receive special treatment. They are initialized using the\n * top-level spec property, or, if undefined in the spec, using\n * the corresponding top-level config property. If this property\n * is a signal reference object, the signal expression maps to the\n * signal 'update' property. If the spec's top-level signal array\n * contains an entry that matches a built-in signal, that entry\n * will be merged with the built-in specification, potentially\n * overwriting existing 'value' or 'update' properties.\n */\nfunction collectSignals(spec, config) {\n  const _ = name => value(spec[name], config[name]),\n        signals = [\n          signalObject('background', _('background')),\n          signalObject('autosize', parseAutosize(_('autosize'))),\n          signalObject('padding', parsePadding(_('padding'))),\n          signalObject('width', _('width') || 0),\n          signalObject('height', _('height') || 0)\n        ],\n        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),\n        map = {};\n\n  // add spec signal array\n  array(spec.signals).forEach(s => {\n    if (hasOwnProperty(pre, s.name)) {\n      // merge if built-in signal\n      s = extend(pre[s.name], s);\n    } else {\n      // otherwise add to signal list\n      signals.push(s);\n    }\n    map[s.name] = s;\n  });\n\n  // add config signal array\n  array(config.signals).forEach(s => {\n    if (!hasOwnProperty(map, s.name) && !hasOwnProperty(pre, s.name)) {\n      // add to signal list if not already defined\n      signals.push(s);\n    }\n  });\n\n  return signals;\n}\n","import DataScope from './DataScope';\n\nimport {\n  Compare, Expression, Field, Key, Projection, Proxy, Scale, Sieve\n} from './transforms';\n\nimport {\n  Ascending, Entry, aggrField, compareRef, fieldRef, isExpr,\n  isSignal, keyRef, operator, ref\n} from './util';\n\nimport parseScope from './parsers/scope';\nimport {parseExpression} from 'vega-functions';\n\nimport {\n  array, error, extend, hasOwnProperty,\n  isArray, isObject, isString, peek, stringValue\n} from 'vega-util';\n\nexport default function Scope(config, options) {\n  this.config = config || {};\n  this.options = options || {};\n\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.eventConfig = null;\n  this.locale = null;\n\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n  this.options = scope.options;\n  this.legends = scope.legends;\n\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nScope.prototype = Subscope.prototype = {\n  parse(spec) {\n    return parseScope(spec, this);\n  },\n\n  fork() {\n    return new Subscope(this);\n  },\n\n  isSubscope() {\n    return this._subid > 0;\n  },\n\n  toRuntime() {\n    this.finish();\n    return {\n      description: this.description,\n      operators:   this.operators,\n      streams:     this.streams,\n      updates:     this.updates,\n      bindings:    this.bindings,\n      eventConfig: this.eventConfig,\n      locale:      this.locale\n    };\n  },\n\n  id() {\n    return (this._subid ? this._subid + ':' : 0) + this._id++;\n  },\n\n  add(op) {\n    this.operators.push(op);\n    op.id = this.id();\n    // if pre-registration references exist, resolve them now\n    if (op.refs) {\n      op.refs.forEach(ref => { ref.$ref = op.id; });\n      op.refs = null;\n    }\n    return op;\n  },\n\n  proxy(op) {\n    const vref = op instanceof Entry ? ref(op) : op;\n    return this.add(Proxy({value: vref}));\n  },\n\n  addStream(stream) {\n    this.streams.push(stream);\n    stream.id = this.id();\n    return stream;\n  },\n\n  addUpdate(update) {\n    this.updates.push(update);\n    return update;\n  },\n\n  // Apply metadata\n  finish() {\n    let name, ds;\n\n    // annotate root\n    if (this.root) this.root.root = true;\n\n    // annotate signals\n    for (name in this.signals) {\n      this.signals[name].signal = name;\n    }\n\n    // annotate scales\n    for (name in this.scales) {\n      this.scales[name].scale = name;\n    }\n\n    // annotate data sets\n    function annotate(op, name, type) {\n      let data, list;\n      if (op) {\n        data = op.data || (op.data = {});\n        list = data[name] || (data[name] = []);\n        list.push(type);\n      }\n    }\n    for (name in this.data) {\n      ds = this.data[name];\n      annotate(ds.input,  name, 'input');\n      annotate(ds.output, name, 'output');\n      annotate(ds.values, name, 'values');\n      for (const field in ds.index) {\n        annotate(ds.index[field], name, 'index:' + field);\n      }\n    }\n\n    return this;\n  },\n\n  // ----\n\n  pushState(encode, parent, lookup) {\n    this._encode.push(ref(this.add(Sieve({pulse: encode}))));\n    this._parent.push(parent);\n    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n    this._markpath.push(-1);\n  },\n\n  popState() {\n    this._encode.pop();\n    this._parent.pop();\n    this._lookup.pop();\n    this._markpath.pop();\n  },\n\n  parent() {\n    return peek(this._parent);\n  },\n\n  encode() {\n    return peek(this._encode);\n  },\n\n  lookup() {\n    return peek(this._lookup);\n  },\n\n  markpath() {\n    const p = this._markpath;\n    return ++p[p.length-1];\n  },\n\n  // ----\n\n  fieldRef(field, name) {\n    if (isString(field)) return fieldRef(field, name);\n    if (!field.signal) {\n      error('Unsupported field reference: ' + stringValue(field));\n    }\n\n    const s = field.signal;\n    let f = this.field[s];\n\n    if (!f) {\n      const params = {name: this.signalRef(s)};\n      if (name) params.as = name;\n      this.field[s] = f = ref(this.add(Field(params)));\n    }\n    return f;\n  },\n\n  compareRef(cmp) {\n    let signal = false;\n\n    const check = _ => isSignal(_)\n      ? (signal = true, this.signalRef(_.signal))\n      : isExpr(_) ? (signal = true, this.exprRef(_.expr))\n      : _;\n\n    const fields = array(cmp.field).map(check),\n          orders = array(cmp.order).map(check);\n\n    return signal\n      ? ref(this.add(Compare({fields: fields, orders: orders})))\n      : compareRef(fields, orders);\n  },\n\n  keyRef(fields, flat) {\n    let signal = false;\n\n    const check = _ => isSignal(_)\n      ? (signal = true, ref(sig[_.signal]))\n      : _;\n\n    const sig = this.signals;\n    fields = array(fields).map(check);\n\n    return signal\n      ? ref(this.add(Key({fields: fields, flat: flat})))\n      : keyRef(fields, flat);\n  },\n\n  sortRef(sort) {\n    if (!sort) return sort;\n\n    // including id ensures stable sorting\n    const a = aggrField(sort.op, sort.field),\n         o = sort.order || Ascending;\n\n    return o.signal\n      ? ref(this.add(Compare({\n          fields: a,\n          orders: this.signalRef(o.signal)\n        })))\n      : compareRef(a, o);\n  },\n\n  // ----\n\n  event(source, type) {\n    const key = source + ':' + type;\n    if (!this.events[key]) {\n      const id = this.id();\n      this.streams.push({\n        id: id,\n        source: source,\n        type: type\n      });\n      this.events[key] = id;\n    }\n    return this.events[key];\n  },\n\n  // ----\n\n  hasOwnSignal(name) {\n    return hasOwnProperty(this.signals, name);\n  },\n\n  addSignal(name, value) {\n    if (this.hasOwnSignal(name)) {\n      error('Duplicate signal name: ' + stringValue(name));\n    }\n    const op = value instanceof Entry ? value : this.add(operator(value));\n    return this.signals[name] = op;\n  },\n\n  getSignal(name) {\n    if (!this.signals[name]) {\n      error('Unrecognized signal name: ' + stringValue(name));\n    }\n    return this.signals[name];\n  },\n\n  signalRef(s) {\n    if (this.signals[s]) {\n      return ref(this.signals[s]);\n    } else if (!hasOwnProperty(this.lambdas, s)) {\n      this.lambdas[s] = this.add(operator(null));\n    }\n    return ref(this.lambdas[s]);\n  },\n\n  parseLambdas() {\n    const code = Object.keys(this.lambdas);\n    for (let i=0, n=code.length; i<n; ++i) {\n      const s = code[i],\n            e = parseExpression(s, this),\n            op = this.lambdas[s];\n      op.params = e.$params;\n      op.update = e.$expr;\n    }\n  },\n\n  property(spec) {\n    return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n  },\n\n  objectProperty(spec) {\n    return (!spec || !isObject(spec)) ? spec\n      : this.signalRef(spec.signal || propertyLambda(spec));\n  },\n\n  exprRef(code, name) {\n    const params = {expr: parseExpression(code, this)};\n    if (name) params.expr.$name = name;\n    return ref(this.add(Expression(params)));\n  },\n\n  addBinding(name, bind) {\n    if (!this.bindings) {\n      error('Nested signals do not support binding: ' + stringValue(name));\n    }\n    this.bindings.push(extend({signal: name}, bind));\n  },\n\n  // ----\n\n  addScaleProj(name, transform) {\n    if (hasOwnProperty(this.scales, name)) {\n      error('Duplicate scale or projection name: ' + stringValue(name));\n    }\n    this.scales[name] = this.add(transform);\n  },\n\n  addScale(name, params) {\n    this.addScaleProj(name, Scale(params));\n  },\n\n  addProjection(name, params) {\n    this.addScaleProj(name, Projection(params));\n  },\n\n  getScale(name) {\n    if (!this.scales[name]) {\n      error('Unrecognized scale name: ' + stringValue(name));\n    }\n    return this.scales[name];\n  },\n\n  scaleRef(name) {\n    return ref(this.getScale(name));\n  },\n\n  scaleType(name) {\n    return this.getScale(name).params.type;\n  },\n\n  projectionRef(name) {\n    return this.scaleRef(name);\n  },\n\n  projectionType(name) {\n    return this.scaleType(name);\n  },\n\n  // ----\n\n  addData(name, dataScope) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return (this.data[name] = dataScope);\n  },\n\n  getData(name) {\n    if (!this.data[name]) {\n      error('Undefined data set name: ' + stringValue(name));\n    }\n    return this.data[name];\n  },\n\n  addDataPipeline(name, entries) {\n    if (hasOwnProperty(this.data, name)) {\n      error('Duplicate data set name: ' + stringValue(name));\n    }\n    return this.addData(name, DataScope.fromEntries(this, entries));\n  }\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  const n = array.length;\n  let code = '[';\n\n  for (let i = 0; i<n; ++i) {\n    const value = array[i];\n    code += (i > 0 ? ',' : '')\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  let code = '{',\n      i = 0,\n      key, value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '')\n      + stringValue(key) + ':'\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + '}';\n}\n","/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nexport default function() {\n  const defaultFont = 'sans-serif',\n        defaultSymbolSize = 30,\n        defaultStrokeWidth = 2,\n        defaultColor = '#4c78a8',\n        black = '#000',\n        gray = '#888',\n        lightGray = '#ddd';\n\n  return {\n    // default visualization description\n    description: 'Vega visualization',\n\n    // default padding around visualization\n    padding: 0,\n\n    // default for automatic sizing; options: 'none', 'pad', 'fit'\n    // or provide an object (e.g., {'type': 'pad', 'resize': true})\n    autosize: 'pad',\n\n    // default view background color\n    // covers the entire view component\n    background: null,\n\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {allow: ['wheel']}\n    },\n\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: {\n      fill: defaultColor\n    },\n    area: {\n      fill: defaultColor\n    },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: {\n      stroke: defaultColor\n    },\n    rect: {\n      fill: defaultColor\n    },\n    rule: {\n      stroke: black\n    },\n    shape: {\n      stroke: defaultColor\n    },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n    trail: {\n      fill: defaultColor,\n      size: defaultStrokeWidth\n    },\n\n    // style definitions\n    style: {\n      // axis & legend labels\n      'guide-label': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      'guide-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      'group-title': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // chart subtitle\n      'group-subtitle': {\n        fill: black,\n        font: defaultFont,\n        fontSize: 12\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      },\n      view: {\n        fill: 'transparent'\n      }\n    },\n\n    // defaults for title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4,\n      subtitlePadding: 3\n    },\n\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelOffset: 0,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titlePadding: 4\n    },\n\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -0.5\n    },\n\n    // defaults for cartographic projection\n    projection: {\n      type: 'mercator'\n    },\n\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolLimit: 30,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleLimit: 180,\n      titleOrient: 'top',\n      titlePadding: 5,\n      layout: {\n        offset: 18,\n        direction: 'horizontal',\n        left:   { direction: 'vertical' },\n        right:  { direction: 'vertical' }\n      }\n    },\n\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues'\n      },\n      heatmap: {\n        scheme: 'yellowgreenblue'\n      },\n      ramp: {\n        scheme: 'blues'\n      },\n      diverging: {\n        scheme: 'blueorange',\n        extent: [1, 0]\n      },\n      symbol: [\n        'circle',\n        'square',\n        'triangle-up',\n        'cross',\n        'diamond',\n        'triangle-right',\n        'triangle-down',\n        'triangle-left'\n      ]\n    }\n  };\n}\n","import parseView from './parsers/view';\nimport Scope from './Scope';\nimport defaults from './config';\nimport {error, isObject, mergeConfig} from 'vega-util';\n\nexport default function(spec, config, options) {\n  if (!isObject(spec)) {\n    error('Input Vega specification must be an object.');\n  }\n\n  config = mergeConfig(defaults(), config, spec.config);\n  return parseView(spec, new Scope(config, options)).toRuntime();\n}\n"],"names":["parseAutosize","spec","isObject","type","number","_","paddingObject","top","bottom","left","right","parsePadding","signal","encoder","isArray","extend","value","addEncode","object","name","set","length","update","addEncoders","enter","extendEncode","encode","extra","skip","hasOwnProperty","has","key","MarkRole","FrameRole","ScopeRole","AxisRole","AxisDomainRole","AxisGridRole","AxisLabelRole","AxisTickRole","AxisTitleRole","LegendRole","LegendBandRole","LegendEntryRole","LegendGradientRole","LegendLabelRole","LegendSymbolRole","LegendTitleRole","TitleRole","TitleTextRole","TitleSubtitleRole","applyDefault","defaults","scaleRef","scale","isString","stringValue","field","entry","enc","gradient","args","start","stop","count","map","peek","pop","unshift","join","color","c","_color","h","l","s","a","b","r","g","undefined","range","band","property","exponent","mult","offset","round","x","y","z","ref","resolveField","datum","level","group","parent","Math","max","error","splitAccessPath","parseEncode","role","style","scope","params","encoders","$encode","config","props","String","startsWith","mark","array","forEach","applyDefaults","parseBlock","block","marktype","channels","fields","parse","code","rule","test","$expr","$fields","Object","keys","$output","expr","parseExpression","$params","OUTER","OUTER_INVALID","outerError","prefix","parseSignal","push","signals","prop","op","addSignal","react","bind","addBinding","Entry","this","id","operator","$ref","refs","fieldRef","$field","$name","keyFieldRef","compareRef","orders","$compare","$order","Descending","aggrField","Scope","View","isSignal","hasSignal","specValue","defaultValue","deref","v","Timer","parseStream","stream","merge","mergeStream","nestedStream","eventStream","streamParameters","addStream","source","event","throttle","between","filter","param","concat","markname","markrole","item","filterMark","debounce","consume","OP_VALUE_EXPR","ast","parseUpdate","target","events","sources","parseSelector","isSubscope","mergeSources","$value","signalRef","force","options","addUpdate","streamSource","parseSignalUpdates","getSignal","init","initonly","on","transform","Aggregate","AxisTicks","Bound","Collect","Compare","DataJoin","Encode","Expression","Facet","Field","Key","LegendEntries","Load","Mark","MultiExtent","MultiValues","Overlap","Params","PreFacet","Projection","Proxy","Relay","Render","Scale","Sieve","SortItems","ViewLayout","Values","FIELD_REF_ID","MULTIDOMAIN_SORT_OPS","min","parseScale","getScale","domain","parseScaleDomain","parseScaleRange","interpolate","parseLiteral","gamma","interpolateGamma","parseScaleInterpolate","nice","interval","step","parseScaleNice","bins","parseArray","objectProperty","parseScaleBins","dataLookupError","explicitDomain","multipleDomain","singularDomain","domainMin","domainMax","data","getData","isDiscrete","valuesRef","parseSort","sort","isQuantile","domainRef","extentRef","reduce","dom","d","coll","$ingest","input","addDataPipeline","ordinalMultipleDomain","quantileMultipleDomain","numericMultipleDomain","counts","f","countsRef","p","groupby","pulse","ops","as","add","sortRef","multidomain","values","extents","scheme","extent","schemeExtent","schemeCount","rangeStep","parseParameter","Top","Left","Right","Bottom","Center","Vertical","Start","End","Index","Label","Offset","Perc","Perc2","Value","GuideLabelStyle","GuideTitleStyle","GroupTitleStyle","GroupSubtitleStyle","Symbols","Gradient","Discrete","Size","LegendScales","Skip","interactive","zero","one","GroupMark","RectMark","RuleMark","SymbolMark","TextMark","guideGroup","lookup","dflt","isVertical","direction","symbolDirection","gradientDirection","gradientLength","gradientWidth","gradientThickness","gradientHeight","entryColumns","columns","getEncoding","anchorExpr","e","m","alignExpr","extendOffset","assign","guideMark","extras","legendGradient","userEncode","vertical","thickness","width","height","opacity","fill","exit","stroke","strokeWidth","legendGradientDiscrete","dataRef","u","uu","vv","adjust","from","baselineExpr","legendGradientLabels","overlap","text","fillOpacity","font","fontSize","fontStyle","fontWeight","limit","labelLimit","gradientLabelLimit","align","baseline","labelOffset","gradientLabelOffset","separation","method","order","legendSymbolGroups","entries","symbolOffset","valueRef","xSignal","yEncode","index","ncols","nrows","baseFill","baseStroke","symbolBaseFillColor","symbolBaseStrokeColor","shape","size","strokeDash","strokeDashOffset","symbols","clip","labels","noBound","row","column","facet","marks","isL","isR","isLR","isVG","exprAlign","exprAnchor","exprAngle","exprBaseline","path","sphere","getRole","definition","zindex","aria","description","parseTransform","def","t","toLowerCase","parseParameters","proxy","metadata","n","i","pdef","lookupRef","parseIndexParameter","parseSubParameter","parseSubParameters","projectionRef","parameterValue","required","isExpr","isField","isCompare","outerExpr","exprRef","outerField","isData","k","getDataRef","output","DataScope","aggr","aggregate","fieldKey","addSortField","cache","ds","optype","sortKey","parseTrigger","remove","insert","toggle","modify","trigger","parseMark","store","layoutRef","boundRef","layout","nested","keyRef","parseData","clean","joinRef","markdef","context","$context","groups","markpath","markRef","mod","tx","md","generates","changes","nomod","encodeRef","legends","bound","operators","pushState","subscope","fork","addData","subflow","$subflow","toRuntime","parseFacet","parseSubflow","popState","sep","tol","tolerance","boundTolerance","boundScale","boundOrient","orient","parseOverlap","render","sieve","parseLegend","legend","legendEncode","scales","entryLayout","children","scaleType","scaleCount","isContinuous","isDiscretizing","legendType","title","vgrad","entryRef","minstep","tickMinStep","formatType","formatSpecifier","format","center","padding","legendSymbolLayout","getChannel","getStyle","getFontSize","sizeExpression","_anchor","anchor","angle","lineHeight","legendTitle","buildLegendEncode","titlePadding","cornerRadius","fromEntries","prototype","agg","tuplesRef","indataRef","angleExpr","parseTitle","dx","dy","buildTitle","titleEncode","subtitle","buildSubTitle","groupEncode","frame","transforms","upstream","generate","load","collect","$format","url","$request","modifies","derive","splice","analyze","async","isX","getSign","ifLeftTopExpr","ifX","ifXEnc","ifY","ifYEnc","ifTop","ifTopExpr","ifRight","ifRightExpr","$orient","ifEnc","ifExpr","isSimple","toExpr","ifOrient","sign","patch","base","endsWith","slice","fallback","axisConfig","styleProp","objects","obj","position","pos","axisGrid","vscale","gridScale","offsetValue","strokeCap","strokeOpacity","tickPos","sz","gridStart","gridEnd","x2","y2","flushExpr","threshold","axisTitle","titlePos","auto","dim","autoY","autoX","autoLayout","parseAxis","xy","or","axis","axisBand","xyKeys","axisX","axisY","orientKeys","axisTop","axisBottom","axisLeft","axisRight","toUpperCase","axisEncode","tickBand","ticks","grid","ticksRef","tickCount","tickSize","axisTicks","flush","flushOffset","labelAlign","labelBaseline","flushOn","offsetExpr","axisLabels","pos0","pos1","axisDomain","buildAxisEncode","minExtent","maxExtent","translate","parseScope","preprocessed","projections","proj","projection","addProjection","parseProjection","isValidScaleType","addScale","initScale","axes","parseLambdas","rootEncode","parseView","root","signalObject","pre","collectSignals","eventConfig","locale","autosize","parseSpec","bindings","lambdas","streams","updates","_id","_subid","_nextsub","_parent","_encode","_lookup","_markpath","Subscope","create","propertyLambda","arrayLambda","objectLambda","defaultFont","defaultColor","black","gray","lightGray","background","allow","arc","area","image","line","rect","symbol","trail","point","circle","square","cell","view","subtitlePadding","bandPosition","domainWidth","domainColor","gridWidth","gridColor","labelAngle","labelPadding","tickColor","tickOffset","tickRound","tickWidth","gridAlign","columnPadding","rowPadding","gradientStrokeColor","gradientStrokeWidth","labelOverlap","symbolLimit","symbolType","symbolSize","symbolStrokeWidth","titleLimit","titleOrient","category","ordinal","heatmap","ramp","diverging","finish","vref","annotate","list","cmp","check","flat","sig","$key","$flat","o","hasOwnSignal","addScaleProj","projectionType","dataScope","mergeConfig"],"mappings":"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"}