{"version":3,"file":"vega-runtime.min.js","sources":["../src/util.js","../src/expression.js","../src/parameters.js","../src/state.js","../src/context.js","../src/dataflow.js","../src/operator.js","../src/stream.js","../src/update.js"],"sourcesContent":["import {toSet} from 'vega-util';\n\nconst Skip = toSet(['rule']),\n      Swap = toSet(['group', 'image', 'rect']);\n\nexport function adjustSpatial(encode, marktype) {\n  let code = '';\n\n  if (Skip[marktype]) return code;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n\n  return code;\n}\n\nexport function canonicalType(type) {\n  return (type + '').toLowerCase();\n}\n\nexport function isOperator(type) {\n   return canonicalType(type) === 'operator';\n}\n\nexport function isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n","import {adjustSpatial} from './util';\nimport {stringValue} from 'vega-util';\n\nfunction expression(ctx, args, code) {\n  // wrap code in return statement if expression does not terminate\n  if (!code.endsWith(';')) {\n    code = 'return(' + code + ');';\n  }\n  const fn = Function(...args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n}\n\n// generate code for comparing a single field\nfunction _compare(u, v, lt, gt) {\n  return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}\n  : (u > v || v == null) && u != null ? ${gt}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}\n  : v !== v && u === u ? ${gt} : `;\n}\n\nexport default {\n  /**\n   * Parse an expression used to update an operator value.\n   */\n  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n\n  /**\n   * Parse an expression provided as an operator parameter value.\n   */\n  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n\n  /**\n   * Parse an expression applied to an event stream.\n   */\n  event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n\n  /**\n   * Parse an expression used to handle an event-driven operator update.\n   */\n  handler: (ctx, expr) => {\n    const code = `var datum=event.item&&event.item.datum;return ${expr.code};`;\n    return expression(ctx, ['_', 'event'], code);\n  },\n\n  /**\n   * Parse an expression that performs visual encoding.\n   */\n  encode: (ctx, encode) => {\n    const {marktype, channels} = encode;\n\n    let code = 'var o=item,datum=o.datum,m=0,$;';\n    for (const name in channels) {\n      const o ='o[' + stringValue(name) + ']';\n      code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;\n    }\n    code += adjustSpatial(channels, marktype);\n    code += 'return m;';\n\n    return expression(ctx, ['item', '_'], code);\n  },\n\n  /**\n   * Optimized code generators for access and comparison.\n   */\n  codegen: {\n    get(path) {\n      const ref = `[${path.map(stringValue).join('][')}]`;\n      const get = Function('_', `return _${ref};`);\n      get.path = ref;\n      return get;\n    },\n    comparator(fields, orders) {\n      let t;\n      const map = (f, i) => {\n        const o = orders[i];\n        let u, v;\n        if (f.path) {\n          u = `a${f.path}`;\n          v = `b${f.path}`;\n        } else {\n          (t = t || {})['f'+i] = f;\n          u = `this.f${i}(a)`;\n          v = `this.f${i}(b)`;\n        }\n        return _compare(u, v, -o, o);\n      };\n\n      const fn = Function('a', 'b', 'var u, v; return '\n        + fields.map(map).join('') + '0;');\n      return t ? fn.bind(t) : fn;\n    }\n  }\n};\n","import {tupleid} from 'vega-dataflow';\nimport {\n  accessor, array, compare, error, field,\n  hasOwnProperty, isArray, isObject, key\n} from 'vega-util';\n\n/**\n * Parse a set of operator parameters.\n */\nexport default function parseParameters(spec, params) {\n  params = params || {};\n  const ctx = this;\n\n  for (const key in spec) {\n    const value = spec[key];\n    params[key] = isArray(value)\n      ? value.map(v => parseParameter(v, ctx, params))\n      : parseParameter(value, ctx, params);\n  }\n\n  return params;\n}\n\n/**\n * Parse a single parameter.\n */\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (let i=0, n=PARSERS.length, p; i<n; ++i) {\n    p = PARSERS[i];\n    if (hasOwnProperty(spec, p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n\n  return spec;\n}\n\n/** Reference parsers. */\nvar PARSERS = [\n  {key: '$ref',      parse: getOperator},\n  {key: '$key',      parse: getKey},\n  {key: '$expr',     parse: getExpression},\n  {key: '$field',    parse: getField},\n  {key: '$encode',   parse: getEncode},\n  {key: '$compare',  parse: getCompare},\n  {key: '$context',  parse: getContext},\n  {key: '$subflow',  parse: getSubflow},\n  {key: '$tupleid',  parse: getTupleId}\n];\n\n/**\n * Resolve an operator reference.\n */\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n\n/**\n * Resolve an expression reference.\n */\nfunction getExpression(_, ctx, params) {\n  if (_.$params) { // parse expression parameters\n    ctx.parseParameters(_.$params, params);\n  }\n  const k = 'e:' + _.$expr.code;\n  return ctx.fn[k] || (ctx.fn[k] = accessor(\n    ctx.parameterExpression(_.$expr),\n    _.$fields\n  ));\n}\n\n/**\n * Resolve a key accessor reference.\n */\nfunction getKey(_, ctx) {\n  const k = 'k:' + _.$key + '_' + (!!_.$flat);\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat, ctx.expr.codegen));\n}\n\n/**\n * Resolve a field accessor reference.\n */\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  const k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name, ctx.expr.codegen));\n}\n\n/**\n * Resolve a comparator function reference.\n */\nfunction getCompare(_, ctx) {\n  // As of Vega 5.5.3, $tupleid sort is no longer used.\n  // Keep here for now for backwards compatibility.\n  const k = 'c:' + _.$compare + '_' + _.$order,\n        c = array(_.$compare).map(_ => (_ && _.$tupleid) ? tupleid : _);\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order, ctx.expr.codegen));\n}\n\n/**\n * Resolve an encode operator reference.\n */\nfunction getEncode(_, ctx) {\n  const spec = _.$encode,\n        encode = {};\n\n  for (const name in spec) {\n    const enc = spec[name];\n    encode[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n  return encode;\n}\n\n/**\n * Resolve a context reference.\n */\nfunction getContext(_, ctx) {\n  return ctx;\n}\n\n/**\n * Resolve a recursive subflow specification.\n */\nfunction getSubflow(_, ctx) {\n  const spec = _.$subflow;\n  return function(dataflow, key, parent) {\n    const subctx = ctx.fork().parse(spec),\n          op = subctx.get(spec.operators[0].id),\n          p = subctx.signals.parent;\n    if (p) p.set(parent);\n    op.detachSubflow = () => ctx.detach(subctx);\n    return op;\n  };\n}\n\n/**\n * Resolve a tuple id reference.\n */\nfunction getTupleId() {\n  return tupleid;\n}\n","import {truthy} from 'vega-util';\n\nconst SKIP = {skip: true};\n\nexport function getState(options) {\n  var ctx = this,\n      state = {};\n\n  if (options.signals) {\n    var signals = (state.signals = {});\n    Object.keys(ctx.signals).forEach(key => {\n      const op = ctx.signals[key];\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n\n  if (options.data) {\n    var data = (state.data = {});\n    Object.keys(ctx.data).forEach(key => {\n      const dataset = ctx.data[key];\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n  }\n\n  return state;\n}\n\nexport function setState(state) {\n  var ctx = this,\n      df = ctx.dataflow,\n      data = state.data,\n      signals = state.signals;\n\n  Object.keys(signals || {}).forEach(key => {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n\n  Object.keys(data || {}).forEach(key => {\n    df.pulse(\n      ctx.data[key].input,\n      df.changeset().remove(truthy).insert(data[key])\n    );\n  });\n\n  (state.subcontext  || []).forEach((substate, i) => {\n    const subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n","import parse from './dataflow';\nimport expressionCodegen from './expression';\nimport {\n  parseOperator,\n  parseOperatorParameters\n} from './operator';\nimport parseParameters from './parameters';\nimport parseStream from './stream';\nimport parseUpdate from './update';\n\nimport {getState, setState} from './state';\nimport {canonicalType, isCollect} from './util';\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\nexport default function(df, transforms, functions, expr) {\n  return new Context(df, transforms, functions, expr);\n}\n\nfunction Context(df, transforms, functions, expr) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.expr = expr || expressionCodegen,\n  this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction Subcontext(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.events = ctx.events;\n  this.expr = ctx.expr;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = Subcontext.prototype = {\n  fork() {\n    const ctx = new Subcontext(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  detach(ctx) {\n    this.subcontext = this.subcontext.filter(c => c !== ctx);\n\n    // disconnect all nodes in the subcontext\n    // wipe out targets first for better efficiency\n    const keys = Object.keys(ctx.nodes);\n    for (const key of keys) ctx.nodes[key]._targets = null;\n    for (const key of keys) ctx.nodes[key].detach();\n    ctx.nodes = null;\n  },\n  get(id) {\n    return this.nodes[id];\n  },\n  set(id, node) {\n    return this.nodes[id] = node;\n  },\n  add(spec, op) {\n    const ctx = this,\n          df = ctx.dataflow,\n          data = spec.value;\n\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && data) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$request) {\n        df.preload(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      let p = ctx.get(spec.parent.$ref);\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(() => {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (const name in spec.data) {\n        const data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(role => data[role] = op);\n      }\n    }\n  },\n  resolve() {\n    (this.unresolved || []).forEach(fn => fn());\n    delete this.unresolved;\n    return this;\n  },\n  operator(spec, update) {\n    this.add(spec, this.dataflow.add(spec.value, update));\n  },\n  transform(spec, type) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n  },\n  stream(spec, stream) {\n    this.set(spec.id, stream);\n  },\n  update(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n\n  // expression parsing\n  operatorExpression(expr) {\n    return this.expr.operator(this, expr);\n  },\n  parameterExpression(expr) {\n    return this.expr.parameter(this, expr);\n  },\n  eventExpression(expr) {\n    return this.expr.event(this, expr);\n  },\n  handlerExpression(expr) {\n    return this.expr.handler(this, expr);\n  },\n  encodeExpression(encode) {\n    return this.expr.encode(this, encode);\n  },\n\n  // parse methods\n  parse,\n  parseOperator,\n  parseOperatorParameters,\n  parseParameters,\n  parseStream,\n  parseUpdate,\n\n  // state methods\n  getState,\n  setState\n};\n","/**\n * Parse a serialized dataflow specification.\n */\nexport default function(spec) {\n  const ctx = this,\n        operators = spec.operators || [];\n\n  // parse background\n  if (spec.background) {\n    ctx.background = spec.background;\n  }\n\n  // parse event configuration\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  }\n\n  // parse locale configuration\n  if (spec.locale) {\n    ctx.locale = spec.locale;\n  }\n\n  // parse operators\n  operators.forEach(entry => ctx.parseOperator(entry));\n\n  // parse operator parameters\n  operators.forEach(entry => ctx.parseOperatorParameters(entry));\n\n  // parse streams\n  (spec.streams || []).forEach(entry => ctx.parseStream(entry));\n\n  // parse updates\n  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n\n  return ctx.resolve();\n}\n","import {isOperator} from './util';\nimport {error} from 'vega-util';\n\n/**\n * Parse a dataflow operator.\n */\nexport function parseOperator(spec) {\n  const ctx = this;\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(\n      spec,\n      spec.update ? ctx.operatorExpression(spec.update) : null\n    );\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n\n/**\n * Parse and assign operator parameters.\n */\nexport function parseOperatorParameters(spec) {\n  const ctx = this;\n  if (spec.params) {\n    const op = ctx.get(spec.id);\n    if (!op) error('Invalid operator id: ' + spec.id);\n    ctx.dataflow.connect(op, op.parameters(\n      ctx.parseParameters(spec.params),\n      spec.react,\n      spec.initonly\n    ));\n  }\n}\n","import {error} from 'vega-util';\n\n/**\n * Parse an event stream specification.\n */\nexport default function(spec) {\n  var ctx = this,\n      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n      args;\n\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  }\n  else if (spec.merge) {\n    args = spec.merge.map(_ => ctx.get(_));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n\n  if (spec.between) {\n    args = spec.between.map(_ => ctx.get(_));\n    stream = stream.between(args[0], args[1]);\n  }\n\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n\n  if (spec.consume) stream.consume(true);\n\n  ctx.stream(spec, stream);\n}\n","import {error, isObject} from 'vega-util';\n\n/**\n * Parse an event-driven operator update.\n */\nexport default function(spec) {\n  var ctx = this,\n      srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n      source = ctx.get(srcid),\n      target = null,\n      update = spec.update,\n      params = undefined;\n\n  if (!source) error('Source not defined: ' + spec.source);\n\n  target = spec.target && spec.target.$expr\n    ? ctx.eventExpression(spec.target.$expr)\n    : ctx.get(spec.target);\n\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = ctx.parseParameters(update.$params);\n    }\n    update = ctx.handlerExpression(update.$expr);\n  }\n\n  ctx.update(spec, source, target, update, params);\n}\n"],"names":["Skip","toSet","Swap","canonicalType","type","toLowerCase","expression","ctx","args","code","endsWith","fn","Function","concat","functions","bind","expressionCodegen","operator","expr","parameter","event","handler","encode","marktype","channels","name","o","stringValue","x2","x","xc","y2","y","yc","adjustSpatial","codegen","get","path","ref","map","join","comparator","fields","orders","t","f","i","u","v","lt","gt","_compare","parseParameter","spec","params","isObject","p","n","PARSERS","length","hasOwnProperty","key","parse","_","$ref","error","k","$key","$flat","$params","parseParameters","$expr","accessor","parameterExpression","$fields","$field","$name","field","$encode","enc","encodeExpression","output","$output","$compare","$order","c","array","$tupleid","tupleid","compare","$subflow","dataflow","parent","subctx","fork","op","operators","id","signals","set","detachSubflow","detach","SKIP","skip","Context","df","transforms","this","events","scales","nodes","data","Object","create","context","Subcontext","prototype","subcontext","push","filter","keys","_targets","node","add","value","$ingest","ingest","$format","$request","preload","pulse","changeset","insert","root","connect","targets","unresolved","signal","scale","forEach","role","resolve","update","transform","stream","target","on","options","operatorExpression","eventExpression","handlerExpression","background","eventConfig","locale","entry","parseOperator","parseOperatorParameters","streams","parseStream","updates","parseUpdate","parameters","react","initonly","isArray","undefined","source","merge","apply","slice","between","throttle","debounce","JSON","stringify","consume","srcid","getState","state","dataset","input","recurse","setState","remove","truthy","substate"],"mappings":"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"}