!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("vega-util"),require("vega-dataflow")):"function"==typeof define&&define.amd?define(["exports","vega-util","vega-dataflow"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).vega={},e.vega,e.vega)}(this,(function(e,t,r){"use strict";const n=t.toSet(["rule"]),o=t.toSet(["group","image","rect"]);function s(e){return(e+"").toLowerCase()}function a(e,t,r){r.endsWith(";")||(r="return("+r+");");const n=Function(...t.concat(r));return e&&e.functions?n.bind(e.functions):n}var i={operator:(e,t)=>a(e,["_"],t.code),parameter:(e,t)=>a(e,["datum","_"],t.code),event:(e,t)=>a(e,["event"],t.code),handler:(e,t)=>a(e,["_","event"],`var datum=event.item&&event.item.datum;return ${t.code};`),encode:(e,r)=>{const{marktype:s,channels:i}=r;let c="var o=item,datum=o.datum,m=0,$;";for(const e in i){const r="o["+t.stringValue(e)+"]";c+=`$=${i[e].code};if(${r}!==$)${r}=$,m=1;`}return c+=function(e,t){let r="";return n[t]||(e.x2&&(e.x?(o[t]&&(r+="if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"),r+="o.width=o.x2-o.x;"):r+="o.x=o.x2-(o.width||0);"),e.xc&&(r+="o.x=o.xc-(o.width||0)/2;"),e.y2&&(e.y?(o[t]&&(r+="if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"),r+="o.height=o.y2-o.y;"):r+="o.y=o.y2-(o.height||0);"),e.yc&&(r+="o.y=o.yc-(o.height||0)/2;")),r}(i,s),c+="return m;",a(e,["item","_"],c)},codegen:{get(e){const r=`[${e.map(t.stringValue).join("][")}]`,n=Function("_",`return _${r};`);return n.path=r,n},comparator(e,t){let r;const n=Function("a","b","var u, v; return "+e.map(((e,n)=>{const o=t[n];let s,a;return e.path?(s=`a${e.path}`,a=`b${e.path}`):((r=r||{})["f"+n]=e,s=`this.f${n}(a)`,a=`this.f${n}(b)`),function(e,t,r,n){return`((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${r}\n  : (u > v || v == null) && u != null ? ${n}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${r}\n  : v !== v && u === u ? ${n} : `}(s,a,-o,o)})).join("")+"0;");return r?n.bind(r):n}}};function c(e,r,n){if(!e||!t.isObject(e))return e;for(let o,s=0,a=u.length;s<a;++s)if(o=u[s],t.hasOwnProperty(e,o.key))return o.parse(e,r,n);return e}var u=[{key:"$ref",parse:function(e,r){return r.get(e.$ref)||t.error("Operator not defined: "+e.$ref)}},{key:"$key",parse:function(e,r){const n="k:"+e.$key+"_"+!!e.$flat;return r.fn[n]||(r.fn[n]=t.key(e.$key,e.$flat,r.expr.codegen))}},{key:"$expr",parse:function(e,r,n){e.$params&&r.parseParameters(e.$params,n);const o="e:"+e.$expr.code;return r.fn[o]||(r.fn[o]=t.accessor(r.parameterExpression(e.$expr),e.$fields))}},{key:"$field",parse:function(e,r){if(!e.$field)return null;const n="f:"+e.$field+"_"+e.$name;return r.fn[n]||(r.fn[n]=t.field(e.$field,e.$name,r.expr.codegen))}},{key:"$encode",parse:function(e,r){const n=e.$encode,o={};for(const e in n){const s=n[e];o[e]=t.accessor(r.encodeExpression(s.$expr),s.$fields),o[e].output=s.$output}return o}},{key:"$compare",parse:function(e,n){const o="c:"+e.$compare+"_"+e.$order,s=t.array(e.$compare).map((e=>e&&e.$tupleid?r.tupleid:e));return n.fn[o]||(n.fn[o]=t.compare(s,e.$order,n.expr.codegen))}},{key:"$context",parse:function(e,t){return t}},{key:"$subflow",parse:function(e,t){const r=e.$subflow;return function(e,n,o){const s=t.fork().parse(r),a=s.get(r.operators[0].id),i=s.signals.parent;return i&&i.set(o),a.detachSubflow=()=>t.detach(s),a}}},{key:"$tupleid",parse:function(){return r.tupleid}}];const f={skip:!0};function p(e,t,r,n){this.dataflow=e,this.transforms=t,this.events=e.events.bind(e),this.expr=n||i,this.signals={},this.scales={},this.nodes={},this.data={},this.fn={},r&&(this.functions=Object.create(r),this.functions.context=this)}function d(e){this.dataflow=e.dataflow,this.transforms=e.transforms,this.events=e.events,this.expr=e.expr,this.signals=Object.create(e.signals),this.scales=Object.create(e.scales),this.nodes=Object.create(e.nodes),this.data=Object.create(e.data),this.fn=Object.create(e.fn),e.functions&&(this.functions=Object.create(e.functions),this.functions.context=this)}p.prototype=d.prototype={fork(){const e=new d(this);return(this.subcontext||(this.subcontext=[])).push(e),e},detach(e){this.subcontext=this.subcontext.filter((t=>t!==e));const t=Object.keys(e.nodes);for(const r of t)e.nodes[r]._targets=null;for(const r of t)e.nodes[r].detach();e.nodes=null},get(e){return this.nodes[e]},set(e,t){return this.nodes[e]=t},add(e,t){const r=this,n=r.dataflow,o=e.value;if(r.set(e.id,t),"collect"===s(e.type)&&o&&(o.$ingest?n.ingest(t,o.$ingest,o.$format):o.$request?n.preload(t,o.$request,o.$format):n.pulse(t,n.changeset().insert(o))),e.root&&(r.root=t),e.parent){let o=r.get(e.parent.$ref);o?(n.connect(o,[t]),t.targets().add(o)):(r.unresolved=r.unresolved||[]).push((()=>{o=r.get(e.parent.$ref),n.connect(o,[t]),t.targets().add(o)}))}if(e.signal&&(r.signals[e.signal]=t),e.scale&&(r.scales[e.scale]=t),e.data)for(const n in e.data){const o=r.data[n]||(r.data[n]={});e.data[n].forEach((e=>o[e]=t))}},resolve(){return(this.unresolved||[]).forEach((e=>e())),delete this.unresolved,this},operator(e,t){this.add(e,this.dataflow.add(e.value,t))},transform(e,t){this.add(e,this.dataflow.add(this.transforms[s(t)]))},stream(e,t){this.set(e.id,t)},update(e,t,r,n,o){this.dataflow.on(t,r,n,o,e.options)},operatorExpression(e){return this.expr.operator(this,e)},parameterExpression(e){return this.expr.parameter(this,e)},eventExpression(e){return this.expr.event(this,e)},handlerExpression(e){return this.expr.handler(this,e)},encodeExpression(e){return this.expr.encode(this,e)},parse:function(e){const t=this,r=e.operators||[];return e.background&&(t.background=e.background),e.eventConfig&&(t.eventConfig=e.eventConfig),e.locale&&(t.locale=e.locale),r.forEach((e=>t.parseOperator(e))),r.forEach((e=>t.parseOperatorParameters(e))),(e.streams||[]).forEach((e=>t.parseStream(e))),(e.updates||[]).forEach((e=>t.parseUpdate(e))),t.resolve()},parseOperator:function(e){const t=this;"operator"!==s(e.type)&&e.type?t.transform(e,e.type):t.operator(e,e.update?t.operatorExpression(e.update):null)},parseOperatorParameters:function(e){const r=this;if(e.params){const n=r.get(e.id);n||t.error("Invalid operator id: "+e.id),r.dataflow.connect(n,n.parameters(r.parseParameters(e.params),e.react,e.initonly))}},parseParameters:function(e,r){r=r||{};const n=this;for(const o in e){const s=e[o];r[o]=t.isArray(s)?s.map((e=>c(e,n,r))):c(s,n,r)}return r},parseStream:function(e){var r,n=this,o=null!=e.filter?n.eventExpression(e.filter):void 0,s=null!=e.stream?n.get(e.stream):void 0;e.source?s=n.events(e.source,e.type,o):e.merge&&(s=(r=e.merge.map((e=>n.get(e))))[0].merge.apply(r[0],r.slice(1))),e.between&&(r=e.between.map((e=>n.get(e))),s=s.between(r[0],r[1])),e.filter&&(s=s.filter(o)),null!=e.throttle&&(s=s.throttle(+e.throttle)),null!=e.debounce&&(s=s.debounce(+e.debounce)),null==s&&t.error("Invalid stream definition: "+JSON.stringify(e)),e.consume&&s.consume(!0),n.stream(e,s)},parseUpdate:function(e){var r,n=this,o=t.isObject(o=e.source)?o.$ref:o,s=n.get(o),a=e.update,i=void 0;s||t.error("Source not defined: "+e.source),r=e.target&&e.target.$expr?n.eventExpression(e.target.$expr):n.get(e.target),a&&a.$expr&&(a.$params&&(i=n.parseParameters(a.$params)),a=n.handlerExpression(a.$expr)),n.update(e,s,r,a,i)},getState:function(e){var t=this,r={};if(e.signals){var n=r.signals={};Object.keys(t.signals).forEach((r=>{const o=t.signals[r];e.signals(r,o)&&(n[r]=o.value)}))}if(e.data){var o=r.data={};Object.keys(t.data).forEach((r=>{const n=t.data[r];e.data(r,n)&&(o[r]=n.input.value)}))}return t.subcontext&&!1!==e.recurse&&(r.subcontext=t.subcontext.map((t=>t.getState(e)))),r},setState:function(e){var r=this,n=r.dataflow,o=e.data,s=e.signals;Object.keys(s||{}).forEach((e=>{n.update(r.signals[e],s[e],f)})),Object.keys(o||{}).forEach((e=>{n.pulse(r.data[e].input,n.changeset().remove(t.truthy).insert(o[e]))})),(e.subcontext||[]).forEach(((e,t)=>{const n=r.subcontext[t];n&&n.setState(e)}))}},e.context=function(e,t,r,n){return new p(e,t,r,n)}}));
//# sourceMappingURL=vega-runtime.min.js.map
