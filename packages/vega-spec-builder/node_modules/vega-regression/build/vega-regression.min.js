!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("vega-statistics"),require("vega-dataflow"),require("vega-util")):"function"==typeof define&&define.amd?define(["exports","vega-statistics","vega-dataflow","vega-util"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).vega={},e.vega,e.vega,e.vega)}(this,(function(e,r,a,t){"use strict";function s(e,r){var a,t,s,n,o,i,l=[],u=function(e){return e(n)};if(null==r)l.push(e);else for(a={},t=0,s=e.length;t<s;++t)n=e[t],(i=a[o=r.map(u)])||(a[o]=i=[],i.dims=o,l.push(i)),i.push(n);return l}function n(e){a.Transform.call(this,null,e)}n.Definition={type:"Loess",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"bandwidth",type:"number",default:.3},{name:"as",type:"string",array:!0}]},t.inherits(n,a.Transform,{transform(e,n){const o=n.fork(n.NO_SOURCE|n.NO_FIELDS);if(!this.value||n.changed()||e.modified()){const i=s(n.materialize(n.SOURCE).source,e.groupby),l=(e.groupby||[]).map(t.accessorName),u=l.length,d=e.as||[t.accessorName(e.x),t.accessorName(e.y)],f=[];i.forEach((t=>{r.regressionLoess(t,e.x,e.y,e.bandwidth||.3).forEach((e=>{const r={};for(let e=0;e<u;++e)r[l[e]]=t.dims[e];r[d[0]]=e[0],r[d[1]]=e[1],f.push(a.ingest(r))}))})),this.value&&(o.rem=this.value),this.value=o.add=o.source=f}return o}});const o={constant:r.regressionConstant,linear:r.regressionLinear,log:r.regressionLog,exp:r.regressionExp,pow:r.regressionPow,quad:r.regressionQuad,poly:r.regressionPoly};function i(e){a.Transform.call(this,null,e)}i.Definition={type:"Regression",metadata:{generates:!0},params:[{name:"x",type:"field",required:!0},{name:"y",type:"field",required:!0},{name:"groupby",type:"field",array:!0},{name:"method",type:"string",default:"linear",values:Object.keys(o)},{name:"order",type:"number",default:3},{name:"extent",type:"number",array:!0,length:2},{name:"params",type:"boolean",default:!1},{name:"as",type:"string",array:!0}]},t.inherits(i,a.Transform,{transform(e,n){const i=n.fork(n.NO_SOURCE|n.NO_FIELDS);if(!this.value||n.changed()||e.modified()){const l=s(n.materialize(n.SOURCE).source,e.groupby),u=(e.groupby||[]).map(t.accessorName),d=e.method||"linear",f=null==e.order?3:e.order,m=((e,r)=>"poly"===e?r:"quad"===e?2:1)(d,f),p=e.as||[t.accessorName(e.x),t.accessorName(e.y)],g=o[d],c=[];let h=e.extent;t.hasOwnProperty(o,d)||t.error("Invalid regression method: "+d),null!=h&&"log"===d&&h[0]<=0&&(n.dataflow.warn("Ignoring extent with values <= 0 for log regression."),h=null),l.forEach((s=>{if(s.length<=m)return void n.dataflow.warn("Skipping regression with more parameters than data points.");const o=g(s,e.x,e.y,f);if(e.params)return void c.push(a.ingest({keys:s.dims,coef:o.coef,rSquared:o.rSquared}));const i=h||t.extent(s,e.x),l=e=>{const r={};for(let e=0;e<u.length;++e)r[u[e]]=s.dims[e];r[p[0]]=e[0],r[p[1]]=e[1],c.push(a.ingest(r))};"linear"===d||"constant"===d?i.forEach((e=>l([e,o.predict(e)]))):r.sampleCurve(o.predict,i,25,200).forEach(l)})),this.value&&(i.rem=this.value),this.value=i.add=i.source=c}return i}}),e.loess=n,e.regression=i}));
//# sourceMappingURL=vega-regression.min.js.map
