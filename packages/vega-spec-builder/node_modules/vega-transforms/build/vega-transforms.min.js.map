{"version":3,"file":"vega-transforms.min.js","sources":["../src/util/AggregateKeys.js","../src/util/AggregateOps.js","../src/util/TupleStore.js","../src/Aggregate.js","../src/Bin.js","../src/util/SortedList.js","../src/Collect.js","../src/Compare.js","../src/CountPattern.js","../src/Cross.js","../src/util/Distributions.js","../src/Density.js","../src/util/util.js","../src/DotBin.js","../src/Expression.js","../src/Extent.js","../src/Subflow.js","../src/Facet.js","../src/Field.js","../src/Filter.js","../src/Flatten.js","../src/Fold.js","../src/Formula.js","../src/Generate.js","../../../node_modules/d3-array/src/ascending.js","../../../node_modules/d3-array/src/descending.js","../../../node_modules/d3-array/src/bisector.js","../../../node_modules/d3-array/src/sort.js","../../../node_modules/d3-array/src/max.js","../../../node_modules/d3-array/src/min.js","../../../node_modules/d3-array/src/quickselect.js","../../../node_modules/d3-array/src/range.js","../src/Impute.js","../../../node_modules/d3-array/src/median.js","../../../node_modules/d3-array/src/quantile.js","../../../node_modules/d3-array/src/number.js","../../../node_modules/d3-array/src/mean.js","../src/JoinAggregate.js","../src/KDE.js","../src/Key.js","../src/Load.js","../src/Lookup.js","../src/MultiExtent.js","../src/MultiValues.js","../src/Params.js","../src/Pivot.js","../src/PreFacet.js","../src/Project.js","../src/Proxy.js","../src/Quantile.js","../src/Relay.js","../src/Sample.js","../src/Sequence.js","../src/Sieve.js","../src/TimeUnit.js","../src/TupleIndex.js","../src/Values.js","../src/util/WindowOps.js","../src/util/WindowState.js","../src/Window.js"],"sourcesContent":["export function multikey(f) {\n  return x => {\n    const n = f.length;\n    let i = 1,\n        k = String(f[0](x));\n\n    for (; i<n; ++i) {\n      k += '|' + f[i](x);\n    }\n\n    return k;\n  };\n}\n\nexport function groupkey(fields) {\n  return !fields || !fields.length ? function() { return ''; }\n    : fields.length === 1 ? fields[0]\n    : multikey(fields);\n}\n","import {extend, identity} from 'vega-util';\n\nexport function measureName(op, field, as) {\n  return as || (op + (!field ? '' : '_' + field));\n}\n\nconst noop = () => {};\n\nconst base_op = {\n  init: noop,\n  add:  noop,\n  rem:  noop,\n  idx:  0\n};\n\nexport const AggregateOps = {\n  values: {\n    init:  m => m.cell.store = true,\n    value: m => m.cell.data.values(),\n    idx:  -1\n  },\n  count: {\n    value: m => m.cell.num\n  },\n  __count__: {\n    value: m => m.missing + m.valid\n  },\n  missing: {\n    value: m => m.missing\n  },\n  valid: {\n    value: m => m.valid\n  },\n  sum: {\n    init:  m => m.sum = 0,\n    value: m => m.valid ? m.sum : undefined,\n    add:  (m, v) => m.sum += +v,\n    rem:  (m, v) => m.sum -= v\n  },\n  product: {\n    init:  m => m.product = 1,\n    value: m => m.valid ? m.product : undefined,\n    add:  (m, v) => m.product *= v,\n    rem:  (m, v) => m.product /= v\n  },\n  mean: {\n    init:  m => m.mean = 0,\n    value: m => m.valid ? m.mean : undefined,\n    add:  (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),\n    rem:  (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)\n  },\n  average: {\n    value: m => m.valid ? m.mean : undefined,\n    req:  ['mean'], idx: 1\n  },\n  variance: {\n    init:  m => m.dev = 0,\n    value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,\n    add:  (m, v) => m.dev += m.mean_d * (v - m.mean),\n    rem:  (m, v) => m.dev -= m.mean_d * (v - m.mean),\n    req:  ['mean'], idx: 1\n  },\n  variancep: {\n    value: m => m.valid > 1 ? m.dev / m.valid : undefined,\n    req:  ['variance'], idx: 2\n  },\n  stdev: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,\n    req:  ['variance'], idx: 2\n  },\n  stdevp: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,\n    req:  ['variance'], idx: 2\n  },\n  stderr: {\n    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,\n    req:  ['variance'], idx: 2\n  },\n  distinct: {\n    value: m => m.cell.data.distinct(m.get),\n    req:  ['values'], idx: 3\n  },\n  ci0: {\n    value: m => m.cell.data.ci0(m.get),\n    req:  ['values'], idx: 3\n  },\n  ci1: {\n    value: m => m.cell.data.ci1(m.get),\n    req:  ['values'], idx: 3\n  },\n  median: {\n    value: m => m.cell.data.q2(m.get),\n    req:  ['values'], idx: 3\n  },\n  q1: {\n    value: m => m.cell.data.q1(m.get),\n    req: ['values'], idx: 3\n  },\n  q3: {\n    value: m => m.cell.data.q3(m.get),\n    req:  ['values'], idx: 3\n  },\n  min: {\n    init:  m => m.min = undefined,\n    value: m => m.min = (Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min),\n    add:  (m, v) => { if (v < m.min || m.min === undefined) m.min = v; },\n    rem:  (m, v) => { if (v <= m.min) m.min = NaN; },\n    req:  ['values'], idx: 4\n  },\n  max: {\n    init:  m => m.max = undefined,\n    value: m => m.max = (Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max),\n    add:  (m, v) => { if (v > m.max || m.max === undefined) m.max = v; },\n    rem:  (m, v) => { if (v >= m.max) m.max = NaN; },\n    req:  ['values'], idx: 4\n  },\n  argmin: {\n    init:  m => m.argmin = undefined,\n    value: m => m.argmin || m.cell.data.argmin(m.get),\n    add:  (m, v, t) => { if (v < m.min) m.argmin = t; },\n    rem:  (m, v) => { if (v <= m.min) m.argmin = undefined; },\n    req:  ['min', 'values'], idx: 3\n  },\n  argmax: {\n    init:  m => m.argmax = undefined,\n    value: m => m.argmax || m.cell.data.argmax(m.get),\n    add:  (m, v, t) => { if (v > m.max) m.argmax = t; },\n    rem:  (m, v) => { if (v >= m.max) m.argmax = undefined; },\n    req:  ['max', 'values'], idx: 3\n  },\n  exponential: {\n    init: (m, r) => { m.exp = 0; m.exp_r = r; },\n    value: m => m.valid ? (m.exp * (1 - m.exp_r) / (1 - m.exp_r ** m.valid)) : undefined,\n    add:  (m, v) => m.exp = m.exp_r * m.exp + v,\n    rem:  (m, v) => m.exp = (m.exp - v / m.exp_r ** (m.valid - 1)) / m.exp_r\n  },\n  exponentialb: {\n    value: m => m.valid ? (m.exp * (1 - m.exp_r)) : undefined,\n    req:  ['exponential'], idx: 1\n  }\n};\n\nexport const ValidAggregateOps = Object.keys(AggregateOps).filter(d => d !== '__count__');\n\nfunction measure(key, value) {\n  return (out, aggregate_param) => extend({\n    name: key,\n    aggregate_param: aggregate_param,\n    out: out || key\n  }, base_op, value);\n}\n\n[...ValidAggregateOps, '__count__'].forEach(key => {\n  AggregateOps[key] = measure(key, AggregateOps[key]);\n});\n\nexport function createMeasure(op, param, name) {\n  return AggregateOps[op](name, param);\n}\n\nfunction compareIndex(a, b) {\n  return a.idx - b.idx;\n}\n\nfunction resolve(agg) {\n  const map = {};\n  agg.forEach(a => map[a.name] = a);\n\n  const getreqs = a => {\n    if (!a.req) return;\n    a.req.forEach(key => {\n      if (!map[key]) getreqs(map[key] = AggregateOps[key]());\n    });\n  };\n  agg.forEach(getreqs);\n\n  return Object.values(map).sort(compareIndex);\n}\n\nfunction init() {\n  this.valid = 0;\n  this.missing = 0;\n  this._ops.forEach(op => (op.aggregate_param == null) ? op.init(this) : op.init(this, op.aggregate_param));\n}\n\nfunction add(v, t) {\n  if (v == null || v === '') { ++this.missing; return; }\n  if (v !== v) return;\n  ++this.valid;\n  this._ops.forEach(op => op.add(this, v, t));\n}\n\nfunction rem(v, t) {\n  if (v == null || v === '') { --this.missing; return; }\n  if (v !== v) return;\n  --this.valid;\n  this._ops.forEach(op => op.rem(this, v, t));\n}\n\nfunction set(t) {\n  this._out.forEach(op => t[op.out] = op.value(this));\n  return t;\n}\n\nexport function compileMeasures(agg, field) {\n  const get = field || identity,\n        ops = resolve(agg),\n        out = agg.slice().sort(compareIndex);\n\n  function ctr(cell) {\n    this._ops = ops;\n    this._out = out;\n    this.cell = cell;\n    this.init();\n  }\n\n  ctr.prototype.init = init;\n  ctr.prototype.add = add;\n  ctr.prototype.rem = rem;\n  ctr.prototype.set = set;\n  ctr.prototype.get = get;\n  ctr.fields = agg.map(op => op.out);\n\n  return ctr;\n}\n","import {tupleid} from 'vega-dataflow';\nimport {bootstrapCI, quartiles} from 'vega-statistics';\nimport {extentIndex, field, hasOwnProperty} from 'vega-util';\n\nexport default function TupleStore(key) {\n  this._key = key ? field(key) : tupleid;\n  this.reset();\n}\n\nconst prototype = TupleStore.prototype;\n\nprototype.reset = function() {\n  this._add = [];\n  this._rem = [];\n  this._ext = null;\n  this._get = null;\n  this._q = null;\n};\n\nprototype.add = function(v) {\n  this._add.push(v);\n};\n\nprototype.rem = function(v) {\n  this._rem.push(v);\n};\n\nprototype.values = function() {\n  this._get = null;\n  if (this._rem.length === 0) return this._add;\n\n  const a = this._add,\n        r = this._rem,\n        k = this._key,\n        n = a.length,\n        m = r.length,\n        x = Array(n - m),\n        map = {};\n  let i, j, v;\n\n  // use unique key field to clear removed values\n  for (i=0; i<m; ++i) {\n    map[k(r[i])] = 1;\n  }\n  for (i=0, j=0; i<n; ++i) {\n    if (map[k(v = a[i])]) {\n      map[k(v)] = 0;\n    } else {\n      x[j++] = v;\n    }\n  }\n\n  this._rem = [];\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nprototype.distinct = function(get) {\n  const v = this.values(),\n        map = {};\n\n  let n = v.length,\n      count = 0, s;\n\n  while (--n >= 0) {\n    s = get(v[n]) + '';\n    if (!hasOwnProperty(map, s)) {\n      map[s] = 1;\n      ++count;\n    }\n  }\n\n  return count;\n};\n\nprototype.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    const v = this.values(),\n          i = extentIndex(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;\n  }\n  return this._ext;\n};\n\nprototype.argmin = function(get) {\n  return this.extent(get)[0] || {};\n};\n\nprototype.argmax = function(get) {\n  return this.extent(get)[1] || {};\n};\n\nprototype.min = function(get) {\n  const m = this.extent(get)[0];\n  return m != null ? get(m) : undefined;\n};\n\nprototype.max = function(get) {\n  const m = this.extent(get)[1];\n  return m != null ? get(m) : undefined;\n};\n\nprototype.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = quartiles(this.values(), get);\n    this._get = get;\n  }\n  return this._q;\n};\n\nprototype.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nprototype.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nprototype.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nprototype.ci = function(get) {\n  if (this._get !== get || !this._ci) {\n    this._ci = bootstrapCI(this.values(), 1000, 0.05, get);\n    this._get = get;\n  }\n  return this._ci;\n};\n\nprototype.ci0 = function(get) {\n  return this.ci(get)[0];\n};\n\nprototype.ci1 = function(get) {\n  return this.ci(get)[1];\n};\n","import {groupkey} from './util/AggregateKeys';\nimport {ValidAggregateOps, compileMeasures, createMeasure, measureName} from './util/AggregateOps';\nimport TupleStore from './util/TupleStore';\nimport {Transform, ingest, replace} from 'vega-dataflow';\nimport {accessorFields, accessorName, array, error, inherits} from 'vega-util';\n\n/**\n * Group-by aggregation operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\n * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\n * @param {Array<number>} [params.aggregate_params] - An optional array of parameters for aggregation operations.\n * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\n * @param {boolean} [params.cross=false] - A flag indicating that the full\n *   cross-product of groupby values should be generated, including empty cells.\n *   If true, the drop parameter is ignored and empty cells are retained.\n * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\n */\nexport default function Aggregate(params) {\n  Transform.call(this, null, params);\n\n  this._adds = []; // array of added output tuples\n  this._mods = []; // array of modified output tuples\n  this._alen = 0;  // number of active added tuples\n  this._mlen = 0;  // number of active modified tuples\n  this._drop = true;   // should empty aggregation cells be removed\n  this._cross = false; // produce full cross-product of group-by values\n\n  this._dims = [];   // group-by dimension accessors\n  this._dnames = []; // group-by dimension names\n\n  this._measures = []; // collection of aggregation monoids\n  this._countOnly = false; // flag indicating only count aggregation\n  this._counts = null; // collection of count fields\n  this._prev = null;   // previous aggregation cells\n\n  this._inputs = null;  // array of dependent input tuple field names\n  this._outputs = null; // array of output tuple field names\n}\n\nAggregate.Definition = {\n  'type': 'Aggregate',\n  'metadata': {'generates': true, 'changes': true},\n  'params': [\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidAggregateOps },\n    { 'name': 'aggregate_params', 'type': 'number', 'null': true, 'array': true },\n    { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\n    { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\n    { 'name': 'drop', 'type': 'boolean', 'default': true },\n    { 'name': 'cross', 'type': 'boolean', 'default': false },\n    { 'name': 'key', 'type': 'field' }\n  ]\n};\n\ninherits(Aggregate, Transform, {\n  transform(_, pulse) {\n    const aggr = this,\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          mod = _.modified();\n\n    aggr.stamp = out.stamp;\n\n    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n      aggr._prev = aggr.value;\n      aggr.value = mod ? aggr.init(_) : Object.create(null);\n      pulse.visit(pulse.SOURCE, t => aggr.add(t));\n    } else {\n      aggr.value = aggr.value || aggr.init(_);\n      pulse.visit(pulse.REM, t => aggr.rem(t));\n      pulse.visit(pulse.ADD, t => aggr.add(t));\n    }\n\n    // Indicate output fields and return aggregate tuples.\n    out.modifies(aggr._outputs);\n\n    // Should empty cells be dropped?\n    aggr._drop = _.drop !== false;\n\n    // If domain cross-product requested, generate empty cells as needed\n    // and ensure that empty cells are not dropped\n    if (_.cross && aggr._dims.length > 1) {\n      aggr._drop = false;\n      aggr.cross();\n    }\n\n    if (pulse.clean() && aggr._drop) {\n      out.clean(true).runAfter(() => this.clean());\n    }\n\n    return aggr.changes(out);\n  },\n\n  cross() {\n    const aggr = this,\n          curr = aggr.value,\n          dims = aggr._dnames,\n          vals = dims.map(() => ({})),\n          n = dims.length;\n\n    // collect all group-by domain values\n    function collect(cells) {\n      let key, i, t, v;\n      for (key in cells) {\n        t = cells[key].tuple;\n        for (i=0; i<n; ++i) {\n          vals[i][(v = t[dims[i]])] = v;\n        }\n      }\n    }\n    collect(aggr._prev);\n    collect(curr);\n\n    // iterate over key cross-product, create cells as needed\n    function generate(base, tuple, index) {\n      const name = dims[index],\n          v = vals[index++];\n\n      for (const k in v) {\n        const key = base ? base + '|' + k : k;\n        tuple[name] = v[k];\n        if (index < n) generate(key, tuple, index);\n        else if (!curr[key]) aggr.cell(key, tuple);\n      }\n    }\n    generate('', {}, 0);\n  },\n\n  init(_) {\n    // initialize input and output fields\n    const inputs = (this._inputs = []),\n          outputs = (this._outputs = []),\n          inputMap = {};\n\n    function inputVisit(get) {\n      const fields = array(accessorFields(get)),\n            n = fields.length;\n      let i = 0, f;\n      for (; i<n; ++i) {\n        if (!inputMap[f=fields[i]]) {\n          inputMap[f] = 1;\n          inputs.push(f);\n        }\n      }\n    }\n\n    // initialize group-by dimensions\n    this._dims = array(_.groupby);\n    this._dnames = this._dims.map(d => {\n      const dname = accessorName(d);\n      inputVisit(d);\n      outputs.push(dname);\n      return dname;\n    });\n    this.cellkey = _.key ? _.key : groupkey(this._dims);\n\n    // initialize aggregate measures\n    this._countOnly = true;\n    this._counts = [];\n    this._measures = [];\n\n    const fields = _.fields || [null],\n          ops = _.ops || ['count'],\n          aggregate_params = _.aggregate_params || [null],\n          as = _.as || [],\n          n = fields.length,\n          map = {};\n    let field, op, aggregate_param, m, mname, outname, i;\n\n    if (n !== ops.length) {\n      error('Unmatched number of fields and aggregate ops.');\n    }\n\n    for (i=0; i<n; ++i) {\n      field = fields[i];\n      op = ops[i];\n      aggregate_param = aggregate_params[i] || null;\n\n      if (field == null && op !== 'count') {\n        error('Null aggregate field specified.');\n      }\n      mname = accessorName(field);\n      outname = measureName(op, mname, as[i]);\n      outputs.push(outname);\n\n      if (op === 'count') {\n        this._counts.push(outname);\n        continue;\n      }\n\n      m = map[mname];\n      if (!m) {\n        inputVisit(field);\n        m = (map[mname] = []);\n        m.field = field;\n        this._measures.push(m);\n      }\n\n      if (op !== 'count') this._countOnly = false;\n      m.push(createMeasure(op, aggregate_param, outname));\n    }\n\n    this._measures = this._measures.map(m => compileMeasures(m, m.field));\n\n    return Object.create(null); // aggregation cells (this.value)\n  },\n\n  // -- Cell Management -----\n\n  cellkey: groupkey(),\n\n  cell(key, t) {\n    let cell = this.value[key];\n    if (!cell) {\n      cell = this.value[key] = this.newcell(key, t);\n      this._adds[this._alen++] = cell;\n    } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\n      cell.stamp = this.stamp;\n      this._adds[this._alen++] = cell;\n    } else if (cell.stamp < this.stamp) {\n      cell.stamp = this.stamp;\n      this._mods[this._mlen++] = cell;\n    }\n    return cell;\n  },\n\n  newcell(key, t) {\n    const cell = {\n      key:   key,\n      num:   0,\n      agg:   null,\n      tuple: this.newtuple(t, this._prev && this._prev[key]),\n      stamp: this.stamp,\n      store: false\n    };\n\n    if (!this._countOnly) {\n      const measures = this._measures,\n            n = measures.length;\n\n      cell.agg = Array(n);\n      for (let i=0; i<n; ++i) {\n        cell.agg[i] = new measures[i](cell);\n      }\n    }\n\n    if (cell.store) {\n      cell.data = new TupleStore();\n    }\n\n    return cell;\n  },\n\n  newtuple(t, p) {\n    const names = this._dnames,\n          dims = this._dims,\n          n = dims.length,\n          x = {};\n\n    for (let i=0; i<n; ++i) {\n      x[names[i]] = dims[i](t);\n    }\n\n    return p ? replace(p.tuple, x) : ingest(x);\n  },\n\n  clean() {\n    const cells = this.value;\n    for (const key in cells) {\n      if (cells[key].num === 0) {\n        delete cells[key];\n      }\n    }\n  },\n\n  // -- Process Tuples -----\n\n  add(t) {\n    const key = this.cellkey(t),\n          cell = this.cell(key, t);\n\n    cell.num += 1;\n    if (this._countOnly) return;\n\n    if (cell.store) cell.data.add(t);\n\n    const agg = cell.agg;\n    for (let i=0, n=agg.length; i<n; ++i) {\n      agg[i].add(agg[i].get(t), t);\n    }\n  },\n\n  rem(t) {\n    const key = this.cellkey(t),\n          cell = this.cell(key, t);\n\n    cell.num -= 1;\n    if (this._countOnly) return;\n\n    if (cell.store) cell.data.rem(t);\n\n    const agg = cell.agg;\n    for (let i=0, n=agg.length; i<n; ++i) {\n      agg[i].rem(agg[i].get(t), t);\n    }\n  },\n\n  celltuple(cell) {\n    const tuple = cell.tuple,\n          counts = this._counts;\n\n    // consolidate stored values\n    if (cell.store) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (let i=0, n=counts.length; i<n; ++i) {\n      tuple[counts[i]] = cell.num;\n    }\n    if (!this._countOnly) {\n      const agg = cell.agg;\n      for (let i=0, n=agg.length; i<n; ++i) {\n        agg[i].set(tuple);\n      }\n    }\n\n    return tuple;\n  },\n\n  changes(out) {\n    const adds = this._adds,\n          mods = this._mods,\n          prev = this._prev,\n          drop = this._drop,\n          add = out.add,\n          rem = out.rem,\n          mod = out.mod;\n\n    let cell, key, i, n;\n\n    if (prev) for (key in prev) {\n      cell = prev[key];\n      if (!drop || cell.num) rem.push(cell.tuple);\n    }\n\n    for (i=0, n=this._alen; i<n; ++i) {\n      add.push(this.celltuple(adds[i]));\n      adds[i] = null; // for garbage collection\n    }\n\n    for (i=0, n=this._mlen; i<n; ++i) {\n      cell = mods[i];\n      (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\n      mods[i] = null; // for garbage collection\n    }\n\n    this._alen = this._mlen = 0; // reset list of active cells\n    this._prev = null;\n    return out;\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {bin} from 'vega-statistics';\nimport {accessor, accessorFields, accessorName, inherits, toNumber} from 'vega-util';\n\n// epsilon bias to offset floating point error (#1737)\nconst EPSILON = 1e-14;\n\n/**\n * Generates a binning function for discretizing data.\n * @constructor\n * @param {object} params - The parameters for this operator. The\n *   provided values should be valid options for the {@link bin} function.\n * @param {function(object): *} params.field - The data field to bin.\n */\nexport default function Bin(params) {\n  Transform.call(this, null, params);\n}\n\nBin.Definition = {\n  'type': 'Bin',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'field', 'type': 'field', 'required': true },\n    { 'name': 'interval', 'type': 'boolean', 'default': true },\n    { 'name': 'anchor', 'type': 'number' },\n    { 'name': 'maxbins', 'type': 'number', 'default': 20 },\n    { 'name': 'base', 'type': 'number', 'default': 10 },\n    { 'name': 'divide', 'type': 'number', 'array': true, 'default': [5, 2] },\n    { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2, 'required': true },\n    { 'name': 'span', 'type': 'number' },\n    { 'name': 'step', 'type': 'number' },\n    { 'name': 'steps', 'type': 'number', 'array': true },\n    { 'name': 'minstep', 'type': 'number', 'default': 0 },\n    { 'name': 'nice', 'type': 'boolean', 'default': true },\n    { 'name': 'name', 'type': 'string' },\n    { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['bin0', 'bin1'] }\n  ]\n};\n\ninherits(Bin, Transform, {\n  transform(_, pulse) {\n    const band = _.interval !== false,\n        bins = this._bins(_),\n        start = bins.start,\n        step = bins.step,\n        as = _.as || ['bin0', 'bin1'],\n        b0 = as[0],\n        b1 = as[1];\n\n    let flag;\n    if (_.modified()) {\n      pulse = pulse.reflow(true);\n      flag = pulse.SOURCE;\n    } else {\n      flag = pulse.modified(accessorFields(_.field)) ? pulse.ADD_MOD : pulse.ADD;\n    }\n\n    pulse.visit(flag, band\n      ? t => {\n          const v = bins(t);\n          // minimum bin value (inclusive)\n          t[b0] = v;\n          // maximum bin value (exclusive)\n          // use convoluted math for better floating point agreement\n          // see https://github.com/vega/vega/issues/830\n          // infinite values propagate through this formula! #2227\n          t[b1] = v == null ? null : start + step * (1 + (v - start) / step);\n        }\n      : t => t[b0] = bins(t)\n    );\n\n    return pulse.modifies(band ? as : b0);\n  },\n\n  _bins(_) {\n    if (this.value && !_.modified()) {\n      return this.value;\n    }\n\n    const field = _.field,\n          bins  = bin(_),\n          step  = bins.step;\n    let start = bins.start,\n        stop  = start + Math.ceil((bins.stop - start) / step) * step,\n        a, d;\n\n    if ((a = _.anchor) != null) {\n      d = a - (start + step * Math.floor((a - start) / step));\n      start += d;\n      stop += d;\n    }\n\n    const f = function(t) {\n      let v = toNumber(field(t));\n      return v == null ? null\n        : v < start ? -Infinity\n        : v > stop ? +Infinity\n        : (\n            v = Math.max(start, Math.min(v, stop - step)),\n            start + step * Math.floor(EPSILON + (v - start) / step)\n          );\n    };\n\n    f.start = start;\n    f.stop = bins.stop;\n    f.step = step;\n\n    return this.value = accessor(\n      f,\n      accessorFields(field),\n      _.name || 'bin_' + accessorName(field)\n    );\n  }\n});\n","import {merge} from 'vega-util';\n\nexport default function(idFunc, source, input) {\n  const $ = idFunc;\n  let data = source || [],\n      add = input || [],\n      rem = {},\n      cnt = 0;\n\n  return {\n    add: t => add.push(t),\n    remove: t => rem[$(t)] = ++cnt,\n    size: () => data.length,\n    data: (compare, resort) => {\n      if (cnt) {\n        data = data.filter(t => !rem[$(t)]);\n        rem = {};\n        cnt = 0;\n      }\n      if (resort && compare) {\n        data.sort(compare);\n      }\n      if (add.length) {\n        data = compare\n          ? merge(compare, data, add.sort(compare))\n          : data.concat(add);\n        add = [];\n      }\n      return data;\n    }\n  };\n}","import SortedList from './util/SortedList';\nimport {Transform, stableCompare, tupleid} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Collects all data tuples that pass through this operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for additionally sorting the collected tuples.\n */\nexport default function Collect(params) {\n  Transform.call(this, [], params);\n}\n\nCollect.Definition = {\n  'type': 'Collect',\n  'metadata': {'source': true},\n  'params': [\n    { 'name': 'sort', 'type': 'compare' }\n  ]\n};\n\ninherits(Collect, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.ALL),\n          list = SortedList(tupleid, this.value, out.materialize(out.ADD).add),\n          sort = _.sort,\n          mod = pulse.changed() || (sort &&\n                (_.modified('sort') || pulse.modified(sort.fields)));\n\n    out.visit(out.REM, list.remove);\n\n    this.modified(mod);\n    this.value = out.source = list.data(stableCompare(sort), mod);\n\n    // propagate tree root if defined\n    if (pulse.source && pulse.source.root) {\n      this.value.root = pulse.source.root;\n    }\n\n    return out;\n  }\n});\n","import {Operator} from 'vega-dataflow';\nimport {compare, inherits} from 'vega-util';\n\n/**\n * Generates a comparator function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<string|function>} params.fields - The fields to compare.\n * @param {Array<string>} [params.orders] - The sort orders.\n *   Each entry should be one of \"ascending\" (default) or \"descending\".\n */\nexport default function Compare(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(Compare, Operator);\n\nfunction update(_) {\n  return (this.value && !_.modified())\n    ? this.value\n    : compare(_.fields, _.orders);\n}\n","import {Transform, ingest} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Count regexp-defined pattern occurrences in a text field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - An accessor for the text field.\n * @param {string} [params.pattern] - RegExp string defining the text pattern.\n * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.\n * @param {string} [params.stopwords] - RegExp string of words to ignore.\n */\nexport default function CountPattern(params) {\n  Transform.call(this, null, params);\n}\n\nCountPattern.Definition = {\n  'type': 'CountPattern',\n  'metadata': {'generates': true, 'changes': true},\n  'params': [\n    { 'name': 'field', 'type': 'field', 'required': true },\n    { 'name': 'case', 'type': 'enum', 'values': ['upper', 'lower', 'mixed'], 'default': 'mixed' },\n    { 'name': 'pattern', 'type': 'string', 'default': '[\\\\w\"]+' },\n    { 'name': 'stopwords', 'type': 'string', 'default': '' },\n    { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['text', 'count'] }\n  ]\n};\n\nfunction tokenize(text, tcase, match) {\n  switch (tcase) {\n    case 'upper': text = text.toUpperCase(); break;\n    case 'lower': text = text.toLowerCase(); break;\n  }\n  return text.match(match);\n}\n\ninherits(CountPattern, Transform, {\n  transform(_, pulse) {\n    const process = update => tuple => {\n      var tokens = tokenize(get(tuple), _.case, match) || [], t;\n      for (var i=0, n=tokens.length; i<n; ++i) {\n        if (!stop.test(t = tokens[i])) update(t);\n      }\n    };\n\n    const init = this._parameterCheck(_, pulse),\n          counts = this._counts,\n          match = this._match,\n          stop = this._stop,\n          get = _.field,\n          as = _.as || ['text', 'count'],\n          add = process(t => counts[t] = 1 + (counts[t] || 0)),\n          rem = process(t => counts[t] -= 1);\n\n    if (init) {\n      pulse.visit(pulse.SOURCE, add);\n    } else {\n      pulse.visit(pulse.ADD, add);\n      pulse.visit(pulse.REM, rem);\n    }\n\n    return this._finish(pulse, as); // generate output tuples\n  },\n\n  _parameterCheck(_, pulse) {\n    let init = false;\n\n    if (_.modified('stopwords') || !this._stop) {\n      this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');\n      init = true;\n    }\n\n    if (_.modified('pattern') || !this._match) {\n      this._match = new RegExp((_.pattern || '[\\\\w\\']+'), 'g');\n      init = true;\n    }\n\n    if (_.modified('field') || pulse.modified(_.field.fields)) {\n      init = true;\n    }\n\n    if (init) this._counts = {};\n    return init;\n  },\n\n  _finish(pulse, as) {\n    const counts = this._counts,\n          tuples = this._tuples || (this._tuples = {}),\n          text = as[0],\n          count = as[1],\n          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n    let w, t, c;\n\n    for (w in counts) {\n      t = tuples[w];\n      c = counts[w] || 0;\n      if (!t && c) {\n        tuples[w] = (t = ingest({}));\n        t[text] = w;\n        t[count] = c;\n        out.add.push(t);\n      } else if (c === 0) {\n        if (t) out.rem.push(t);\n        counts[w] = null;\n        tuples[w] = null;\n      } else if (t[count] !== c) {\n        t[count] = c;\n        out.mod.push(t);\n      }\n    }\n\n    return out.modifies(as);\n  }\n});\n","import {Transform, ingest} from 'vega-dataflow';\nimport {inherits, truthy} from 'vega-util';\n\n/**\n * Perform a cross-product of a tuple stream with itself.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object):boolean} [params.filter] - An optional filter\n *   function for selectively including tuples in the cross product.\n * @param {Array<string>} [params.as] - The names of the output fields.\n */\nexport default function Cross(params) {\n  Transform.call(this, null, params);\n}\n\nCross.Definition = {\n  'type': 'Cross',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'filter', 'type': 'expr' },\n    { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['a', 'b'] }\n  ]\n};\n\ninherits(Cross, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          as = _.as || ['a', 'b'],\n          a = as[0], b = as[1],\n          reset = !this.value\n              || pulse.changed(pulse.ADD_REM)\n              || _.modified('as')\n              || _.modified('filter');\n\n    let data = this.value;\n    if (reset) {\n      if (data) out.rem = data;\n      data = pulse.materialize(pulse.SOURCE).source;\n      out.add = this.value = cross(data, a, b, _.filter || truthy);\n    } else {\n      out.mod = data;\n    }\n\n    out.source = this.value;\n    return out.modifies(as);\n  }\n});\n\nfunction cross(input, a, b, filter) {\n  var data = [],\n      t = {},\n      n = input.length,\n      i = 0,\n      j, left;\n\n  for (; i<n; ++i) {\n    t[a] = left = input[i];\n    for (j=0; j<n; ++j) {\n      t[b] = input[j];\n      if (filter(t)) {\n        data.push(ingest(t));\n        t = {};\n        t[a] = left;\n      }\n    }\n  }\n\n  return data;\n}\n","import {\n  randomKDE,\n  randomLogNormal,\n  randomMixture,\n  randomNormal,\n  randomUniform\n} from 'vega-statistics';\n\nimport {error, hasOwnProperty} from 'vega-util';\n\nconst Distributions = {\n  kde:       randomKDE,\n  mixture:   randomMixture,\n  normal:    randomNormal,\n  lognormal: randomLogNormal,\n  uniform:   randomUniform\n};\n\nconst DISTRIBUTIONS = 'distributions',\n      FUNCTION = 'function',\n      FIELD = 'field';\n\n/**\n * Parse a parameter object for a probability distribution.\n * @param {object} def - The distribution parameter object.\n * @param {function():Array<object>} - A method for requesting\n *   source data. Used for distributions (such as KDE) that\n *   require sample data points. This method will only be\n *   invoked if the 'from' parameter for a target data source\n *   is not provided. Typically this method returns backing\n *   source data for a Pulse object.\n * @return {object} - The output distribution object.\n */\nexport default function parse(def, data) {\n  const func = def[FUNCTION];\n  if (!hasOwnProperty(Distributions, func)) {\n    error('Unknown distribution function: ' + func);\n  }\n\n  const d = Distributions[func]();\n\n  for (const name in def) {\n    // if data field, extract values\n    if (name === FIELD) {\n      d.data((def.from || data()).map(def[name]));\n    }\n\n    // if distribution mixture, recurse to parse each definition\n    else if (name === DISTRIBUTIONS) {\n      d[name](def[name].map(_ => parse(_, data)));\n    }\n\n    // otherwise, simply set the parameter\n    else if (typeof d[name] === FUNCTION) {\n      d[name](def[name]);\n    }\n  }\n\n  return d;\n}\n","import parseDist from './util/Distributions';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {sampleCurve} from 'vega-statistics';\nimport {error, extent, inherits} from 'vega-util';\n\n/**\n * Grid sample points for a probability density. Given a distribution and\n * a sampling extent, will generate points suitable for plotting either\n * PDF (probability density function) or CDF (cumulative distribution\n * function) curves.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.distribution - The probability distribution. This\n *   is an object parameter dependent on the distribution type.\n * @param {string} [params.method='pdf'] - The distribution method to sample.\n *   One of 'pdf' or 'cdf'.\n * @param {Array<number>} [params.extent] - The [min, max] extent over which\n *   to sample the distribution. This argument is required in most cases, but\n *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method\n *   that returns numerical sample points from which the extent can be deduced.\n * @param {number} [params.minsteps=25] - The minimum number of curve samples\n *   for plotting the density.\n * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n *   for plotting the density.\n * @param {number} [params.steps] - The exact number of curve samples for\n *   plotting the density. If specified, overrides both minsteps and maxsteps\n *   to set an exact number of uniform samples. Useful in conjunction with\n *   a fixed extent to ensure consistent sample points for stacked densities.\n */\nexport default function Density(params) {\n  Transform.call(this, null, params);\n}\n\nconst distributions = [\n  {\n    'key': {'function': 'normal'},\n    'params': [\n      { 'name': 'mean', 'type': 'number', 'default': 0 },\n      { 'name': 'stdev', 'type': 'number', 'default': 1 }\n    ]\n  },\n  {\n    'key': {'function': 'lognormal'},\n    'params': [\n      { 'name': 'mean', 'type': 'number', 'default': 0 },\n      { 'name': 'stdev', 'type': 'number', 'default': 1 }\n    ]\n  },\n  {\n    'key': {'function': 'uniform'},\n    'params': [\n      { 'name': 'min', 'type': 'number', 'default': 0 },\n      { 'name': 'max', 'type': 'number', 'default': 1 }\n    ]\n  },\n  {\n    'key': {'function': 'kde'},\n    'params': [\n      { 'name': 'field', 'type': 'field', 'required': true },\n      { 'name': 'from', 'type': 'data' },\n      { 'name': 'bandwidth', 'type': 'number', 'default': 0 }\n    ]\n  }\n];\n\nconst mixture = {\n  'key': {'function': 'mixture'},\n  'params': [\n    { 'name': 'distributions', 'type': 'param', 'array': true,\n      'params': distributions },\n    { 'name': 'weights', 'type': 'number', 'array': true }\n  ]\n};\n\nDensity.Definition = {\n  'type': 'Density',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n    { 'name': 'steps', 'type': 'number' },\n    { 'name': 'minsteps', 'type': 'number', 'default': 25 },\n    { 'name': 'maxsteps', 'type': 'number', 'default': 200 },\n    { 'name': 'method', 'type': 'string', 'default': 'pdf',\n      'values': ['pdf', 'cdf'] },\n    { 'name': 'distribution', 'type': 'param',\n      'params': distributions.concat(mixture) },\n    { 'name': 'as', 'type': 'string', 'array': true,\n      'default': ['value', 'density'] }\n  ]\n};\n\ninherits(Density, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const dist = parseDist(_.distribution, source(pulse)),\n            minsteps = _.steps || _.minsteps || 25,\n            maxsteps = _.steps || _.maxsteps || 200;\n      let method = _.method || 'pdf';\n\n      if (method !== 'pdf' && method !== 'cdf') {\n        error('Invalid density method: ' + method);\n      }\n      if (!_.extent && !dist.data) {\n        error('Missing density extent parameter.');\n      }\n      method = dist[method];\n\n      const as = _.as || ['value', 'density'],\n            domain = _.extent || extent(dist.data()),\n            values = sampleCurve(method, domain, minsteps, maxsteps)\n              .map(v => {\n                const tuple = {};\n                tuple[as[0]] = v[0];\n                tuple[as[1]] = v[1];\n                return ingest(tuple);\n              });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\n\nfunction source(pulse) {\n  return () => pulse.materialize(pulse.SOURCE).source;\n}\n","import {accessorName} from 'vega-util';\n\n// use either provided alias or accessor field name\nexport function fieldNames(fields, as) {\n  if (!fields) return null;\n  return fields.map((f, i) => as[i] || accessorName(f));\n}\n\nexport function partition(data, groupby, field) {\n  const groups = [],\n        get = f => f(t);\n  let map, i, n, t, k, g;\n\n  // partition data points into groups\n  if (groupby == null) {\n    groups.push(data.map(field));\n  } else {\n    for (map={}, i=0, n=data.length; i<n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = (g = []);\n        g.dims = k;\n        groups.push(g);\n      }\n      g.push(field(t));\n    }\n  }\n\n  return groups;\n}\n","import {partition} from './util/util';\nimport {Transform, stableCompare} from 'vega-dataflow';\nimport {dotbin} from 'vega-statistics';\nimport {extent, identity, inherits, span} from 'vega-util';\n\nconst Output = 'bin';\n\n/**\n * Dot density binning for dot plot construction.\n * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.\n * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to bin.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {number} [params.step] - The step size (bin width) within which dots should be\n *   stacked. Defaults to 1/30 of the extent of the data *field*.\n * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density\n *   stacks should be smoothed to reduce variance.\n */\nexport default function DotBin(params) {\n  Transform.call(this, null, params);\n}\n\nDotBin.Definition = {\n  'type': 'DotBin',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'field', 'type': 'field', 'required': true },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'step', 'type': 'number' },\n    { 'name': 'smooth', 'type': 'boolean', 'default': false },\n    { 'name': 'as', 'type': 'string', 'default': Output }\n  ]\n};\n\nconst autostep = (data, field) => span(extent(data, field)) / 30;\n\ninherits(DotBin, Transform, {\n  transform(_, pulse) {\n    if (this.value && !(_.modified() || pulse.changed())) {\n      return pulse; // early exit\n    }\n\n    const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(pulse.source, _.groupby, identity),\n          smooth = _.smooth || false,\n          field = _.field,\n          step = _.step || autostep(source, field),\n          sort = stableCompare((a, b) => field(a) - field(b)),\n          as = _.as || Output,\n          n = groups.length;\n\n    // compute dotplot bins per group\n    let min = Infinity, max = -Infinity, i = 0, j;\n    for (; i<n; ++i) {\n      const g = groups[i].sort(sort);\n      j = -1;\n      for (const v of dotbin(g, step, smooth, field)) {\n        if (v < min) min = v;\n        if (v > max) max = v;\n        g[++j][as] = v;\n      }\n    }\n\n    this.value = {\n      start: min,\n      stop: max,\n      step: step\n    };\n    return pulse.reflow(true).modifies(as);\n  }\n});\n","import {Operator} from 'vega-dataflow';\nimport {accessor, accessorFields, accessorName, inherits} from 'vega-util';\n\n/**\n * Wraps an expression function with access to external parameters.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function} params.expr - The expression function. The\n *  function should accept both a datum and a parameter object.\n *  This operator's value will be a new function that wraps the\n *  expression function with access to this operator's parameters.\n */\nexport default function Expression(params) {\n  Operator.call(this, null, update, params);\n  this.modified(true);\n}\n\ninherits(Expression, Operator);\n\nfunction update(_) {\n  const expr = _.expr;\n  return this.value && !_.modified('expr')\n    ? this.value\n    : accessor(\n        datum => expr(datum, _),\n        accessorFields(expr),\n        accessorName(expr)\n      );\n}\n","import {Transform} from 'vega-dataflow';\nimport {accessorName, inherits, toNumber} from 'vega-util';\n\n/**\n * Computes extents (min/max) for a data field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The field over which to compute extends.\n */\nexport default function Extent(params) {\n  Transform.call(this, [undefined, undefined], params);\n}\n\nExtent.Definition = {\n  'type': 'Extent',\n  'metadata': {},\n  'params': [\n    { 'name': 'field', 'type': 'field', 'required': true }\n  ]\n};\n\ninherits(Extent, Transform, {\n  transform(_, pulse) {\n    const extent = this.value,\n          field = _.field,\n          mod = pulse.changed()\n            || pulse.modified(field.fields)\n            || _.modified('field');\n\n    let min = extent[0],\n        max = extent[1];\n    if (mod || min == null) {\n      min = +Infinity;\n      max = -Infinity;\n    }\n\n    pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {\n      const v = toNumber(field(t));\n      if (v != null) {\n        // NaNs will fail all comparisons!\n        if (v < min) min = v;\n        if (v > max) max = v;\n      }\n    });\n\n    if (!Number.isFinite(min) || !Number.isFinite(max)) {\n      let name = accessorName(field);\n      if (name) name = ` for field \"${name}\"`;\n      pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);\n      min = max = undefined;\n    }\n    this.value = [min, max];\n  }\n});\n","import {Operator} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Provides a bridge between a parent transform and a target subflow that\n * consumes only a subset of the tuples that pass through the parent.\n * @constructor\n * @param {Pulse} pulse - A pulse to use as the value of this operator.\n * @param {Transform} parent - The parent transform (typically a Facet instance).\n */\nexport default function Subflow(pulse, parent) {\n  Operator.call(this, pulse);\n  this.parent = parent;\n  this.count = 0;\n}\n\ninherits(Subflow, Operator, {\n  /**\n   * Routes pulses from this subflow to a target transform.\n   * @param {Transform} target - A transform that receives the subflow of tuples.\n   */\n  connect(target) {\n    this.detachSubflow = target.detachSubflow;\n    this.targets().add(target);\n    return (target.source = this);\n  },\n\n  /**\n   * Add an 'add' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being added.\n   */\n  add(t) {\n    this.count += 1;\n    this.value.add.push(t);\n  },\n\n  /**\n   * Add a 'rem' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being removed.\n   */\n  rem(t) {\n    this.count -= 1;\n    this.value.rem.push(t);\n  },\n\n  /**\n   * Add a 'mod' tuple to the subflow pulse.\n   * @param {Tuple} t - The tuple being modified.\n   */\n  mod(t) {\n    this.value.mod.push(t);\n  },\n\n  /**\n   * Re-initialize this operator's pulse value.\n   * @param {Pulse} pulse - The pulse to copy from.\n   * @see Pulse.init\n   */\n  init(pulse) {\n    this.value.init(pulse, pulse.NO_SOURCE);\n  },\n\n  /**\n   * Evaluate this operator. This method overrides the\n   * default behavior to simply return the contained pulse value.\n   * @return {Pulse}\n   */\n  evaluate() {\n    // assert: this.value.stamp === pulse.stamp\n    return this.value;\n  }\n});\n","import Subflow from './Subflow';\nimport {Transform, tupleid} from 'vega-dataflow';\nimport {fastmap, hasOwnProperty, inherits} from 'vega-util';\n\n/**\n * Facets a dataflow into a set of subflows based on a key.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Dataflow, string): Operator} params.subflow - A function\n *   that generates a subflow of operators and returns its root operator.\n * @param {function(object): *} params.key - The key field to facet by.\n */\nexport default function Facet(params) {\n  Transform.call(this, {}, params);\n  this._keys = fastmap(); // cache previously calculated key values\n\n  // keep track of active subflows, use as targets array for listeners\n  // this allows us to limit propagation to only updated subflows\n  const a = this._targets = [];\n  a.active = 0;\n  a.forEach = f => {\n    for (let i=0, n=a.active; i<n; ++i) {\n      f(a[i], i, a);\n    }\n  };\n}\n\ninherits(Facet, Transform, {\n  activate(flow) {\n    this._targets[this._targets.active++] = flow;\n  },\n\n  // parent argument provided by PreFacet subclass\n  subflow(key, flow, pulse, parent) {\n    const flows = this.value;\n    let sf = hasOwnProperty(flows, key) && flows[key],\n        df, p;\n\n    if (!sf) {\n      p = parent || (p = this._group[key]) && p.tuple;\n      df = pulse.dataflow;\n      sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);\n      df.add(sf).connect(flow(df, key, p));\n      flows[key] = sf;\n      this.activate(sf);\n    } else if (sf.value.stamp < pulse.stamp) {\n      sf.init(pulse);\n      this.activate(sf);\n    }\n\n    return sf;\n  },\n\n  clean() {\n    const flows = this.value;\n    let detached = 0;\n    for (const key in flows) {\n      if (flows[key].count === 0) {\n        const detach = flows[key].detachSubflow;\n        if (detach) detach();\n        delete flows[key];\n        ++detached;\n      }\n    }\n\n    // remove inactive targets from the active targets array\n    if (detached) {\n      const active = this._targets.filter(sf => sf && sf.count > 0);\n      this.initTargets(active);\n    }\n  },\n\n  initTargets(act) {\n    const a = this._targets,\n          n = a.length,\n          m = act ? act.length : 0;\n    let i = 0;\n\n    for (; i<m; ++i) {\n      a[i] = act[i];\n    }\n    for (; i<n && a[i] != null; ++i) {\n      a[i] = null; // ensure old flows can be garbage collected\n    }\n    a.active = m;\n  },\n\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n          key = _.key,\n          flow = _.subflow,\n          cache = this._keys,\n          rekey = _.modified('key'),\n          subflow = key => this.subflow(key, flow, pulse);\n\n    this._group = _.group || {};\n    this.initTargets(); // reset list of active subflows\n\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t),\n            k = cache.get(id);\n      if (k !== undefined) {\n        cache.delete(id);\n        subflow(k).rem(t);\n      }\n    });\n\n    pulse.visit(pulse.ADD, t => {\n      const k = key(t);\n      cache.set(tupleid(t), k);\n      subflow(k).add(t);\n    });\n\n    if (rekey || pulse.modified(key.fields)) {\n      pulse.visit(pulse.MOD, t => {\n        const id = tupleid(t),\n              k0 = cache.get(id),\n              k1 = key(t);\n        if (k0 === k1) {\n          subflow(k1).mod(t);\n        } else {\n          cache.set(id, k1);\n          subflow(k0).rem(t);\n          subflow(k1).add(t);\n        }\n      });\n    } else if (pulse.changed(pulse.MOD)) {\n      pulse.visit(pulse.MOD, t => {\n        subflow(cache.get(tupleid(t))).mod(t);\n      });\n    }\n\n    if (rekey) {\n      pulse.visit(pulse.REFLOW, t => {\n        const id = tupleid(t),\n              k0 = cache.get(id),\n              k1 = key(t);\n        if (k0 !== k1) {\n          cache.set(id, k1);\n          subflow(k0).rem(t);\n          subflow(k1).add(t);\n        }\n      });\n    }\n\n    if (pulse.clean()) {\n      df.runAfter(() => { this.clean(); cache.clean(); });\n    } else if (cache.empty > df.cleanThreshold) {\n      df.runAfter(cache.clean);\n    }\n\n    return pulse;\n  }\n});\n","import {Operator} from 'vega-dataflow';\nimport {array, field, inherits, isArray} from 'vega-util';\n\n/**\n * Generates one or more field accessor functions.\n * If the 'name' parameter is an array, an array of field accessors\n * will be created and the 'as' parameter will be ignored.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.name - The field name(s) to access.\n * @param {string} params.as - The accessor function name.\n */\nexport default function Field(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(Field, Operator);\n\nfunction update(_) {\n  return (this.value && !_.modified()) ? this.value\n    : isArray(_.name) ? array(_.name).map(f => field(f))\n    : field(_.name, _.as);\n}\n","import {Transform, tupleid} from 'vega-dataflow';\nimport {fastmap, inherits} from 'vega-util';\n\n/**\n * Filters data tuples according to a predicate function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The predicate expression function\n *   that determines a tuple's filter status. Truthy values pass the filter.\n */\nexport default function Filter(params) {\n  Transform.call(this, fastmap(), params);\n}\n\nFilter.Definition = {\n  'type': 'Filter',\n  'metadata': {'changes': true},\n  'params': [\n    { 'name': 'expr', 'type': 'expr', 'required': true }\n  ]\n};\n\ninherits(Filter, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n          cache = this.value, // cache ids of filtered tuples\n          output = pulse.fork(),\n          add = output.add,\n          rem = output.rem,\n          mod = output.mod,\n          test = _.expr;\n    let isMod = true;\n\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t);\n      if (!cache.has(id)) rem.push(t);\n      else cache.delete(id);\n    });\n\n    pulse.visit(pulse.ADD, t => {\n      if (test(t, _)) add.push(t);\n      else cache.set(tupleid(t), 1);\n    });\n\n    function revisit(t) {\n      const id = tupleid(t),\n            b = test(t, _),\n            s = cache.get(id);\n      if (b && s) {\n        cache.delete(id);\n        add.push(t);\n      } else if (!b && !s) {\n        cache.set(id, 1);\n        rem.push(t);\n      } else if (isMod && b && !s) {\n        mod.push(t);\n      }\n    }\n\n    pulse.visit(pulse.MOD, revisit);\n\n    if (_.modified()) {\n      isMod = false;\n      pulse.visit(pulse.REFLOW, revisit);\n    }\n\n    if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);\n    return output;\n  }\n});\n","import {fieldNames} from './util/util';\nimport {Transform, derive} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Flattens array-typed field values into new data objects.\n * If multiple fields are specified, they are treated as parallel arrays,\n * with output values included for each matching index (or null if missing).\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of field\n *   accessors for the tuple fields that should be flattened.\n * @param {string} [params.index] - Optional output field name for index\n *   value. If unspecified, no index field is included in the output.\n * @param {Array<string>} [params.as] - Output field names for flattened\n *   array fields. Any unspecified fields will use the field name provided\n *   by the fields accessors.\n */\nexport default function Flatten(params) {\n  Transform.call(this, [], params);\n}\n\nFlatten.Definition = {\n  'type': 'Flatten',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n    { 'name': 'index', 'type': 'string' },\n    { 'name': 'as', 'type': 'string', 'array': true }\n  ]\n};\n\ninherits(Flatten, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          as = fieldNames(fields, _.as || []),\n          index = _.index || null,\n          m = as.length;\n\n    // remove any previous results\n    out.rem = this.value;\n\n    // generate flattened tuples\n    pulse.visit(pulse.SOURCE, t => {\n      const arrays = fields.map(f => f(t)),\n            maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);\n      let i = 0, j, d, v;\n\n      for (; i<maxlen; ++i) {\n        d = derive(t);\n        for (j=0; j<m; ++j) {\n          d[as[j]] = (v = arrays[j][i]) == null ? null : v;\n        }\n        if (index) {\n          d[index] = i;\n        }\n        out.add.push(d);\n      }\n    });\n\n    this.value = out.source = out.add;\n    if (index) out.modifies(index);\n    return out.modifies(as);\n  }\n});\n","import {Transform, derive} from 'vega-dataflow';\nimport {accessorName, inherits} from 'vega-util';\n\n/**\n * Folds one more tuple fields into multiple tuples in which the field\n * name and values are available under new 'key' and 'value' fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.fields - An array of field accessors\n *   for the tuple fields that should be folded.\n * @param {Array<string>} [params.as] - Output field names for folded key\n *   and value fields, defaults to ['key', 'value'].\n */\nexport default function Fold(params) {\n  Transform.call(this, [], params);\n}\n\nFold.Definition = {\n  'type': 'Fold',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n    { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': ['key', 'value'] }\n  ]\n};\n\ninherits(Fold, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          fnames = fields.map(accessorName),\n          as = _.as || ['key', 'value'],\n          k = as[0],\n          v = as[1],\n          n = fields.length;\n\n    out.rem = this.value;\n\n    pulse.visit(pulse.SOURCE, t => {\n      for (let i=0, d; i<n; ++i) {\n        d = derive(t);\n        d[k] = fnames[i];\n        d[v] = fields[i](t);\n        out.add.push(d);\n      }\n    });\n\n    this.value = out.source = out.add;\n    return out.modifies(as);\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Invokes a function for each data tuple and saves the results as a new field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The formula function to invoke for each tuple.\n * @param {string} params.as - The field name under which to save the result.\n * @param {boolean} [params.initonly=false] - If true, the formula is applied to\n *   added tuples only, and does not update in response to modifications.\n */\nexport default function Formula(params) {\n  Transform.call(this, null, params);\n}\n\nFormula.Definition = {\n  'type': 'Formula',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'expr', 'type': 'expr', 'required': true },\n    { 'name': 'as', 'type': 'string', 'required': true },\n    { 'name': 'initonly', 'type': 'boolean' }\n  ]\n};\n\ninherits(Formula, Transform, {\n  transform (_, pulse) {\n    const func = _.expr,\n          as = _.as,\n          mod = _.modified(),\n          flag = _.initonly ? pulse.ADD\n            : mod ? pulse.SOURCE\n            : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD\n            : pulse.ADD;\n\n    if (mod) {\n      // parameters updated, need to reflow\n      pulse = pulse.materialize().reflow(true);\n    }\n\n    if (!_.initonly) {\n      pulse.modifies(as);\n    }\n\n    return pulse.visit(flag, t => t[as] = func(t, _));\n  }\n});\n","import {Transform, ingest} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Generates data tuples using a provided generator function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Parameters): object} params.generator - A tuple generator\n *   function. This function is given the operator parameters as input.\n *   Changes to any additional parameters will not trigger re-calculation\n *   of previously generated tuples. Only future tuples are affected.\n * @param {number} params.size - The number of tuples to produce.\n */\nexport default function Generate(params) {\n  Transform.call(this, [], params);\n}\n\ninherits(Generate, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.ALL),\n          gen = _.generator;\n\n    let data = this.value,\n        num = _.size - data.length,\n        add, rem, t;\n\n    if (num > 0) {\n      // need more tuples, generate and add\n      for (add=[]; --num >= 0;) {\n        add.push(t = ingest(gen(_)));\n        data.push(t);\n      }\n      out.add = out.add.length\n        ? out.materialize(out.ADD).add.concat(add)\n        : add;\n    } else {\n      // need fewer tuples, remove\n      rem = data.slice(0, -num);\n      out.rem = out.rem.length\n        ? out.materialize(out.REM).rem.concat(rem)\n        : rem;\n      data = data.slice(-num);\n    }\n\n    out.source = this.value = data;\n    return out;\n  }\n});\n","export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","export default function descending(a, b) {\n  return a == null || b == null ? NaN\n    : b < a ? -1\n    : b > a ? 1\n    : b >= a ? 0\n    : NaN;\n}\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We cant do this\n  // for a comparator (except for specific, known comparators) because we cant\n  // tell if the comparator is symmetric, and an asymmetric comparator cant be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n","import ascending from \"./ascending.js\";\nimport permute from \"./permute.js\";\n\nexport default function sort(values, ...F) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  values = Array.from(values);\n  let [f] = F;\n  if ((f && f.length !== 2) || F.length > 1) {\n    const index = Uint32Array.from(values, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map(f => values.map(f));\n      index.sort((i, j) => {\n        for (const f of F) {\n          const c = ascendingDefined(f[i], f[j]);\n          if (c) return c;\n        }\n      });\n    } else {\n      f = values.map(f);\n      index.sort((i, j) => ascendingDefined(f[i], f[j]));\n    }\n    return permute(values, index);\n  }\n  return values.sort(compareDefined(f));\n}\n\nexport function compareDefined(compare = ascending) {\n  if (compare === ascending) return ascendingDefined;\n  if (typeof compare !== \"function\") throw new TypeError(\"compare is not a function\");\n  return (a, b) => {\n    const x = compare(a, b);\n    if (x || x === 0) return x;\n    return (compare(b, b) === 0) - (compare(a, a) === 0);\n  };\n}\n\nexport function ascendingDefined(a, b) {\n  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);\n}\n","export default function max(values, valueof) {\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  }\n  return max;\n}\n","export default function min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n","import {ascendingDefined, compareDefined} from \"./sort.js\";\n\n// Based on https://github.com/mourner/quickselect\n// ISC license, Copyright 2018 Vladimir Agafonkin.\nexport default function quickselect(array, k, left = 0, right = Infinity, compare) {\n  k = Math.floor(k);\n  left = Math.floor(Math.max(0, left));\n  right = Math.floor(Math.min(array.length - 1, right));\n\n  if (!(left <= k && k <= right)) return array;\n\n  compare = compare === undefined ? ascendingDefined : compareDefined(compare);\n\n  while (right > left) {\n    if (right - left > 600) {\n      const n = right - left + 1;\n      const m = k - left + 1;\n      const z = Math.log(n);\n      const s = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      quickselect(array, k, newLeft, newRight, compare);\n    }\n\n    const t = array[k];\n    let i = left;\n    let j = right;\n\n    swap(array, left, k);\n    if (compare(array[right], t) > 0) swap(array, left, right);\n\n    while (i < j) {\n      swap(array, i, j), ++i, --j;\n      while (compare(array[i], t) < 0) ++i;\n      while (compare(array[j], t) > 0) --j;\n    }\n\n    if (compare(array[left], t) === 0) swap(array, left, j);\n    else ++j, swap(array, j, right);\n\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n\n  return array;\n}\n\nfunction swap(array, i, j) {\n  const t = array[i];\n  array[i] = array[j];\n  array[j] = t;\n}\n","export default function range(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n","import {Transform, ingest} from 'vega-dataflow';\nimport {accessorName, error, inherits} from 'vega-util';\nimport {max, mean, median, min} from 'd3-array';\n\nconst Methods = {\n  value: 'value',\n  median: median,\n  mean: mean,\n  min: min,\n  max: max\n};\n\nconst Empty = [];\n\n/**\n * Impute missing values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to impute.\n * @param {Array<function(object): *>} [params.groupby] - An array of\n *   accessors to determine series within which to perform imputation.\n * @param {function(object): *} params.key - An accessor for a key value.\n *   Each key value should be unique within a group. New tuples will be\n *   imputed for any key values that are not found within a group.\n * @param {Array<*>} [params.keyvals] - Optional array of required key\n *   values. New tuples will be imputed for any key values that are not\n *   found within a group. In addition, these values will be automatically\n *   augmented with the key values observed in the input data.\n * @param {string} [method='value'] - The imputation method to use. One of\n *   'value', 'mean', 'median', 'max', 'min'.\n * @param {*} [value=0] - The constant value to use for imputation\n *   when using method 'value'.\n */\nexport default function Impute(params) {\n  Transform.call(this, [], params);\n}\n\nImpute.Definition = {\n  'type': 'Impute',\n  'metadata': {'changes': true},\n  'params': [\n    { 'name': 'field', 'type': 'field', 'required': true },\n    { 'name': 'key', 'type': 'field', 'required': true },\n    { 'name': 'keyvals', 'array': true },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'method', 'type': 'enum', 'default': 'value',\n      'values': ['value', 'mean', 'median', 'max', 'min'] },\n    { 'name': 'value', 'default': 0 }\n  ]\n};\n\nfunction getValue(_) {\n  var m = _.method || Methods.value, v;\n\n  if (Methods[m] == null) {\n    error('Unrecognized imputation method: ' + m);\n  } else if (m === Methods.value) {\n    v = _.value !== undefined ? _.value : 0;\n    return () => v;\n  } else {\n    return Methods[m];\n  }\n}\n\nfunction getField(_) {\n  const f = _.field;\n  return t => t ? f(t) : NaN;\n}\n\ninherits(Impute, Transform, {\n  transform(_, pulse) {\n    var out = pulse.fork(pulse.ALL),\n        impute = getValue(_),\n        field = getField(_),\n        fName = accessorName(_.field),\n        kName = accessorName(_.key),\n        gNames = (_.groupby || []).map(accessorName),\n        groups = partition(pulse.source, _.groupby, _.key, _.keyvals),\n        curr = [],\n        prev = this.value,\n        m = groups.domain.length,\n        group, value, gVals, kVal, g, i, j, l, n, t;\n\n    for (g=0, l=groups.length; g<l; ++g) {\n      group = groups[g];\n      gVals = group.values;\n      value = NaN;\n\n      // add tuples for missing values\n      for (j=0; j<m; ++j) {\n        if (group[j] != null) continue;\n        kVal = groups.domain[j];\n\n        t = {_impute: true};\n        for (i=0, n=gVals.length; i<n; ++i) t[gNames[i]] = gVals[i];\n        t[kName] = kVal;\n        t[fName] = Number.isNaN(value) ? (value = impute(group, field)) : value;\n\n        curr.push(ingest(t));\n      }\n    }\n\n    // update pulse with imputed tuples\n    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);\n    if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);\n    this.value = curr;\n\n    return out;\n  }\n});\n\nfunction partition(data, groupby, key, keyvals) {\n  var get = f => f(t),\n      groups = [],\n      domain = keyvals ? keyvals.slice() : [],\n      kMap = {},\n      gMap = {}, gVals, gKey,\n      group, i, j, k, n, t;\n\n  domain.forEach((k, i) => kMap[k] = i + 1);\n\n  for (i=0, n=data.length; i<n; ++i) {\n    t = data[i];\n    k = key(t);\n    j = kMap[k] || (kMap[k] = domain.push(k));\n\n    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';\n    if (!(group = gMap[gKey])) {\n      group = (gMap[gKey] = []);\n      groups.push(group);\n      group.values = gVals;\n    }\n    group[j-1] = t;\n  }\n\n  groups.domain = domain;\n  return groups;\n}\n","import quantile, {quantileIndex} from \"./quantile.js\";\n\nexport default function median(values, valueof) {\n  return quantile(values, 0.5, valueof);\n}\n\nexport function medianIndex(values, valueof) {\n  return quantileIndex(values, 0.5, valueof);\n}\n","import max from \"./max.js\";\nimport maxIndex from \"./maxIndex.js\";\nimport min from \"./min.js\";\nimport minIndex from \"./minIndex.js\";\nimport quickselect from \"./quickselect.js\";\nimport number, {numbers} from \"./number.js\";\nimport {ascendingDefined} from \"./sort.js\";\nimport greatest from \"./greatest.js\";\n\nexport default function quantile(values, p, valueof) {\n  values = Float64Array.from(numbers(values, valueof));\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return min(values);\n  if (p >= 1) return max(values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),\n      value1 = min(values.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nexport function quantileSorted(values, p, valueof = number) {\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nexport function quantileIndex(values, p, valueof = number) {\n  if (isNaN(p = +p)) return;\n  numbers = Float64Array.from(values, (_, i) => number(valueof(values[i], i, values)));\n  if (p <= 0) return minIndex(numbers);\n  if (p >= 1) return maxIndex(numbers);\n  var numbers,\n      index = Uint32Array.from(values, (_, i) => i),\n      j = numbers.length - 1,\n      i = Math.floor(j * p);\n  quickselect(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));\n  i = greatest(index.subarray(0, i + 1), (i) => numbers[i]);\n  return i >= 0 ? i : -1;\n}\n","export default function number(x) {\n  return x === null ? NaN : +x;\n}\n\nexport function* numbers(values, valueof) {\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        yield value;\n      }\n    }\n  }\n}\n","export default function mean(values, valueof) {\n  let count = 0;\n  let sum = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        ++count, sum += value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        ++count, sum += value;\n      }\n    }\n  }\n  if (count) return sum / count;\n}\n","import Aggregate from './Aggregate';\nimport {ValidAggregateOps} from './util/AggregateOps';\nimport {extend, inherits} from 'vega-util';\n\n/**\n * Extend input tuples with aggregate values.\n * Calcuates aggregate values and joins them with the input stream.\n * @constructor\n */\nexport default function JoinAggregate(params) {\n  Aggregate.call(this, params);\n}\n\nJoinAggregate.Definition = {\n  'type': 'JoinAggregate',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\n    { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidAggregateOps },\n    { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\n    { 'name': 'key', 'type': 'field' }\n  ]\n};\n\ninherits(JoinAggregate, Aggregate, {\n  transform(_, pulse) {\n    const aggr = this,\n          mod = _.modified();\n    let cells;\n\n    // process all input tuples to calculate aggregates\n    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {\n      cells = aggr.value = mod ? aggr.init(_) : {};\n      pulse.visit(pulse.SOURCE, t => aggr.add(t));\n    } else {\n      cells = aggr.value = aggr.value || this.init(_);\n      pulse.visit(pulse.REM, t => aggr.rem(t));\n      pulse.visit(pulse.ADD, t => aggr.add(t));\n    }\n\n    // update aggregation cells\n    aggr.changes();\n\n    // write aggregate values to input tuples\n    pulse.visit(pulse.SOURCE, t => {\n      extend(t, cells[aggr.cellkey(t)].tuple);\n    });\n\n    return pulse.reflow(mod).modifies(this._outputs);\n  },\n\n  changes() {\n    const adds = this._adds,\n          mods = this._mods;\n    let i, n;\n\n    for (i=0, n=this._alen; i<n; ++i) {\n      this.celltuple(adds[i]);\n      adds[i] = null; // for garbage collection\n    }\n\n    for (i=0, n=this._mlen; i<n; ++i) {\n      this.celltuple(mods[i]);\n      mods[i] = null; // for garbage collection\n    }\n\n    this._alen = this._mlen = 0; // reset list of active cells\n  }\n});\n","import {partition} from './util/util';\nimport {randomKDE} from 'vega-statistics';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {sampleCurve} from 'vega-statistics';\nimport {accessorName, error, extent, inherits} from 'vega-util';\n\n/**\n * Compute kernel density estimates (KDE) for one or more data groups.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {function(object): *} params.field - An accessor for the data field\n *   to estimate.\n * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.\n *   If zero or unspecified, the bandwidth is automatically determined.\n * @param {boolean} [params.counts=false] - A boolean flag indicating if the\n *   output values should be probability estimates (false, default) or\n *   smoothed counts (true).\n * @param {string} [params.cumulative=false] - A boolean flag indicating if a\n *   density (false) or cumulative distribution (true) should be generated.\n * @param {Array<number>} [params.extent] - The domain extent over which to\n *   plot the density. If unspecified, the [min, max] data extent is used.\n * @param {string} [params.resolve='independent'] - Indicates how parameters for\n *   multiple densities should be resolved. If \"independent\" (the default), each\n *   density may have its own domain extent and dynamic number of curve sample\n *   steps. If \"shared\", the KDE transform will ensure that all densities are\n *   defined over a shared domain and curve steps, enabling stacking.\n * @param {number} [params.minsteps=25] - The minimum number of curve samples\n *   for plotting the density.\n * @param {number} [params.maxsteps=200] - The maximum number of curve samples\n *   for plotting the density.\n * @param {number} [params.steps] - The exact number of curve samples for\n *   plotting the density. If specified, overrides both minsteps and maxsteps\n *   to set an exact number of uniform samples. Useful in conjunction with\n *   a fixed extent to ensure consistent sample points for stacked densities.\n */\nexport default function KDE(params) {\n  Transform.call(this, null, params);\n}\n\nKDE.Definition = {\n  'type': 'KDE',\n  'metadata': {'generates': true},\n  'params': [\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'field', 'type': 'field', 'required': true },\n    { 'name': 'cumulative', 'type': 'boolean', 'default': false },\n    { 'name': 'counts', 'type': 'boolean', 'default': false },\n    { 'name': 'bandwidth', 'type': 'number', 'default': 0 },\n    { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n    { 'name': 'resolve', 'type': 'enum', 'values': ['shared', 'independent'], 'default': 'independent' },\n    { 'name': 'steps', 'type': 'number' },\n    { 'name': 'minsteps', 'type': 'number', 'default': 25 },\n    { 'name': 'maxsteps', 'type': 'number', 'default': 200 },\n    { 'name': 'as', 'type': 'string', 'array': true, 'default': ['value', 'density'] }\n  ]\n};\n\ninherits(KDE, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n    if (!this.value || pulse.changed() || _.modified()) {\n      const source = pulse.materialize(pulse.SOURCE).source,\n            groups = partition(source, _.groupby, _.field),\n            names = (_.groupby || []).map(accessorName),\n            bandwidth = _.bandwidth,\n            method = _.cumulative ? 'cdf' : 'pdf',\n            as = _.as || ['value', 'density'],\n            values = [];\n\n      let domain = _.extent,\n          minsteps = _.steps || _.minsteps || 25,\n          maxsteps = _.steps || _.maxsteps || 200;\n\n      if (method !== 'pdf' && method !== 'cdf') {\n        error('Invalid density method: ' + method);\n      }\n\n      if (_.resolve === 'shared') {\n        if (!domain) domain = extent(source, _.field);\n        minsteps = maxsteps = _.steps || maxsteps;\n      }\n\n      groups.forEach(g => {\n        const density = randomKDE(g, bandwidth)[method],\n              scale = _.counts ? g.length : 1,\n              local = domain || extent(g);\n\n        sampleCurve(density, local, minsteps, maxsteps)\n          .forEach(v => {\n            const t = {};\n            for (let i=0; i<names.length; ++i) {\n              t[names[i]] = g.dims[i];\n            }\n            t[as[0]] = v[0];\n            t[as[1]] = v[1] * scale;\n            values.push(ingest(t));\n          });\n      });\n\n      if (this.value) out.rem = this.value;\n      this.value = out.add = out.source = values;\n    }\n\n    return out;\n  }\n});\n","import {Operator} from 'vega-dataflow';\nimport {inherits, key} from 'vega-util';\n\n/**\n * Generates a key function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<string>} params.fields - The field name(s) for the key function.\n * @param {boolean} params.flat - A boolean flag indicating if the field names\n *  should be treated as flat property names, side-stepping nested field\n *  lookups normally indicated by dot or bracket notation.\n */\nexport default function Key(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(Key, Operator);\n\nfunction update(_) {\n  return (this.value && !_.modified()) ? this.value : key(_.fields, _.flat);\n}\n","import {Transform, ingest} from 'vega-dataflow';\nimport {array, inherits} from 'vega-util';\n\n/**\n * Load and parse data from an external source. Marshalls parameter\n * values and then invokes the Dataflow request method.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.url - The URL to load from.\n * @param {object} params.format - The data format options.\n */\nexport default function Load(params) {\n  Transform.call(this, [], params);\n  this._pending = null;\n}\n\ninherits(Load, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow;\n\n    if (this._pending) {\n      // update state and return pulse\n      return output(this, pulse, this._pending);\n    }\n\n    if (stop(_)) return pulse.StopPropagation;\n\n    if (_.values) {\n      // parse and ingest values, return output pulse\n      return output(this, pulse, df.parse(_.values, _.format));\n    } else if (_.async) {\n      // return promise for non-blocking async loading\n      const p = df.request(_.url, _.format).then(res => {\n        this._pending = array(res.data);\n        return df => df.touch(this);\n      });\n      return {async: p};\n    } else {\n      // return promise for synchronous loading\n      return df.request(_.url, _.format)\n        .then(res => output(this, pulse, array(res.data)));\n    }\n  }\n});\n\nfunction stop(_) {\n  return _.modified('async') && !(\n    _.modified('values') || _.modified('url') || _.modified('format')\n  );\n}\n\nfunction output(op, pulse, data) {\n  data.forEach(ingest);\n  const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);\n  out.rem = op.value;\n  op.value = out.source = out.add = data;\n  op._pending = null;\n  if (out.rem.length) out.clean(true);\n  return out;\n}\n","import {Transform} from 'vega-dataflow';\nimport {accessorName, error, inherits} from 'vega-util';\n\n/**\n * Extend tuples by joining them with values from a lookup table.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Map} params.index - The lookup table map.\n * @param {Array<function(object): *} params.fields - The fields to lookup.\n * @param {Array<string>} params.as - Output field names for each lookup value.\n * @param {*} [params.default] - A default value to use if lookup fails.\n */\nexport default function Lookup(params) {\n  Transform.call(this, {}, params);\n}\n\nLookup.Definition = {\n  'type': 'Lookup',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'index', 'type': 'index', 'params': [\n        {'name': 'from', 'type': 'data', 'required': true },\n        {'name': 'key', 'type': 'field', 'required': true }\n      ] },\n    { 'name': 'values', 'type': 'field', 'array': true },\n    { 'name': 'fields', 'type': 'field', 'array': true, 'required': true },\n    { 'name': 'as', 'type': 'string', 'array': true },\n    { 'name': 'default', 'default': null }\n  ]\n};\n\ninherits(Lookup, Transform, {\n  transform(_, pulse) {\n    const keys = _.fields,\n          index = _.index,\n          values = _.values,\n          defaultValue = _.default==null ? null : _.default,\n          reset = _.modified(),\n          n = keys.length;\n\n    let flag = reset ? pulse.SOURCE : pulse.ADD,\n        out = pulse,\n        as = _.as,\n        set, m, mods;\n\n    if (values) {\n      m = values.length;\n\n      if (n > 1 && !as) {\n        error('Multi-field lookup requires explicit \"as\" parameter.');\n      }\n      if (as && as.length !== n * m) {\n        error('The \"as\" parameter has too few output field names.');\n      }\n      as = as || values.map(accessorName);\n\n      set = function(t) {\n        for (var i=0, k=0, j, v; i<n; ++i) {\n          v = index.get(keys[i](t));\n          if (v == null) for (j=0; j<m; ++j, ++k) t[as[k]] = defaultValue;\n          else for (j=0; j<m; ++j, ++k) t[as[k]] = values[j](v);\n        }\n      };\n    } else {\n      if (!as) {\n        error('Missing output field names.');\n      }\n\n      set = function(t) {\n        for (var i=0, v; i<n; ++i) {\n          v = index.get(keys[i](t));\n          t[as[i]] = v==null ? defaultValue : v;\n        }\n      };\n    }\n\n    if (reset) {\n      out = pulse.reflow(true);\n    } else {\n      mods = keys.some(k =>pulse.modified(k.fields));\n      flag |= (mods ? pulse.MOD : 0);\n    }\n    pulse.visit(flag, set);\n\n    return out.modifies(as);\n  }\n});\n","import {Operator} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Computes global min/max extents over a collection of extents.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<Array<number>>} params.extents - The input extents.\n */\nexport default function MultiExtent(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(MultiExtent, Operator);\n\nfunction update(_) {\n  if (this.value && !_.modified()) {\n    return this.value;\n  }\n\n  const ext = _.extents,\n        n = ext.length;\n\n  let min = +Infinity,\n      max = -Infinity,\n      i, e;\n\n  for (i = 0; i < n; ++i) {\n    e = ext[i];\n    if (e[0] < min) min = e[0];\n    if (e[1] > max) max = e[1];\n  }\n  return [min, max];\n}\n","import {Operator} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Merge a collection of value arrays.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<Array<*>>} params.values - The input value arrrays.\n */\nexport default function MultiValues(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(MultiValues, Operator);\n\nfunction update(_) {\n  return (this.value && !_.modified())\n    ? this.value\n    : _.values.reduce((data, _) => data.concat(_), []);\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Operator whose value is simply its parameter hash. This operator is\n * useful for enabling reactive updates to values of nested objects.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nexport default function Params(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Params, Transform, {\n  transform(_, pulse) {\n    this.modified(_.modified());\n    this.value = _;\n    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples\n  }\n});\n","import Aggregate from './Aggregate';\nimport {ValidAggregateOps} from './util/AggregateOps';\nimport {accessor, accessorFields, ascending, inherits} from 'vega-util';\n\n/**\n * Aggregate and pivot selected field values to become new fields.\n * This operator is useful to construction cross-tabulations.\n * @constructor\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *  to groupby. These fields act just like groupby fields of an Aggregate transform.\n * @param {function(object): *} params.field - The field to pivot on. The unique\n *  values of this field become new field names in the output stream.\n * @param {function(object): *} params.value - The field to populate pivoted fields.\n *  The aggregate values of this field become the values of the new pivoted fields.\n * @param {string} [params.op] - The aggregation operation for the value field,\n *  applied per cell in the output stream. The default is \"sum\".\n * @param {number} [params.limit] - An optional parameter indicating the maximum\n *  number of pivoted fields to generate. The pivoted field names are sorted in\n *  ascending order prior to enforcing the limit.\n */\nexport default function Pivot(params) {\n  Aggregate.call(this, params);\n}\n\nPivot.Definition = {\n  'type': 'Pivot',\n  'metadata': {'generates': true, 'changes': true},\n  'params': [\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'field', 'type': 'field', 'required': true },\n    { 'name': 'value', 'type': 'field', 'required': true },\n    { 'name': 'op', 'type': 'enum', 'values': ValidAggregateOps, 'default': 'sum' },\n    { 'name': 'limit', 'type': 'number', 'default': 0 },\n    { 'name': 'key', 'type': 'field' }\n  ]\n};\n\ninherits(Pivot, Aggregate, {\n  _transform: Aggregate.prototype.transform,\n  transform(_, pulse) {\n    return this._transform(aggregateParams(_, pulse), pulse);\n  }\n});\n\n// Shoehorn a pivot transform into an aggregate transform!\n// First collect all unique pivot field values.\n// Then generate aggregate fields for each output pivot field.\nfunction aggregateParams(_, pulse) {\n  const key    = _.field,\n        value  = _.value,\n        op     = (_.op === 'count' ? '__count__' : _.op) || 'sum',\n        fields = accessorFields(key).concat(accessorFields(value)),\n        keys   = pivotKeys(key, _.limit || 0, pulse);\n\n  // if data stream content changes, pivot fields may change\n  // flag parameter modification to ensure re-initialization\n  if (pulse.changed()) _.set('__pivot__', null, null, true);\n\n  return {\n    key:      _.key,\n    groupby:  _.groupby,\n    ops:      keys.map(() => op),\n    fields:   keys.map(k => get(k, key, value, fields)),\n    as:       keys.map(k => k + ''),\n    modified: _.modified.bind(_)\n  };\n}\n\n// Generate aggregate field accessor.\n// Output NaN for non-existent values; aggregator will ignore!\nfunction get(k, key, value, fields) {\n  return accessor(\n    d => key(d) === k ? value(d) : NaN,\n    fields,\n    k + ''\n  );\n}\n\n// Collect (and optionally limit) all unique pivot values.\nfunction pivotKeys(key, limit, pulse) {\n  const map = {},\n        list = [];\n\n  pulse.visit(pulse.SOURCE, t => {\n    const k = key(t);\n    if (!map[k]) {\n      map[k] = 1;\n      list.push(k);\n    }\n  });\n\n  list.sort(ascending);\n\n  return limit ? list.slice(0, limit) : list;\n}\n","import Facet from './Facet';\nimport {ingest, tupleid} from 'vega-dataflow';\nimport {accessorFields, error, inherits} from 'vega-util';\n\n/**\n * Partitions pre-faceted data into tuple subflows.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Dataflow, string): Operator} params.subflow - A function\n *   that generates a subflow of operators and returns its root operator.\n * @param {function(object): Array<object>} params.field - The field\n *   accessor for an array of subflow tuple objects.\n */\nexport default function PreFacet(params) {\n  Facet.call(this, params);\n}\n\ninherits(PreFacet, Facet, {\n  transform(_, pulse) {\n    const flow = _.subflow,\n          field = _.field,\n          subflow = t => this.subflow(tupleid(t), flow, pulse, t);\n\n    if (_.modified('field') || field && pulse.modified(accessorFields(field))) {\n      error('PreFacet does not support field modification.');\n    }\n\n    this.initTargets(); // reset list of active subflows\n\n    if (field) {\n      pulse.visit(pulse.MOD, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.mod(_));\n      });\n\n      pulse.visit(pulse.ADD, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.add(ingest(_)));\n      });\n\n      pulse.visit(pulse.REM, t => {\n        const sf = subflow(t);\n        field(t).forEach(_ => sf.rem(_));\n      });\n    } else {\n      pulse.visit(pulse.MOD, t => subflow(t).mod(t));\n      pulse.visit(pulse.ADD, t => subflow(t).add(t));\n      pulse.visit(pulse.REM, t => subflow(t).rem(t));\n    }\n\n    if (pulse.clean()) {\n      pulse.runAfter(() => this.clean());\n    }\n\n    return pulse;\n  }\n});\n","import {fieldNames} from './util/util';\nimport {Transform, ingest, rederive, tupleid} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Performs a relational projection, copying selected fields from source\n * tuples to a new set of derived tuples.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *} params.fields - The fields to project,\n *   as an array of field accessors. If unspecified, all fields will be\n *   copied with names unchanged.\n * @param {Array<string>} [params.as] - Output field names for each projected\n *   field. Any unspecified fields will use the field name provided by\n *   the field accessor.\n */\nexport default function Project(params) {\n  Transform.call(this, null, params);\n}\n\nProject.Definition = {\n  'type': 'Project',\n  'metadata': {'generates': true, 'changes': true},\n  'params': [\n    { 'name': 'fields', 'type': 'field', 'array': true },\n    { 'name': 'as', 'type': 'string', 'null': true, 'array': true }\n  ]\n};\n\ninherits(Project, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          fields = _.fields,\n          as = fieldNames(_.fields, _.as || []),\n          derive = fields\n            ? (s, t) => project(s, t, fields, as)\n            : rederive;\n\n    let lut;\n    if (this.value) {\n      lut = this.value;\n    } else {\n      pulse = pulse.addAll();\n      lut = this.value = {};\n    }\n\n    pulse.visit(pulse.REM, t => {\n      const id = tupleid(t);\n      out.rem.push(lut[id]);\n      lut[id] = null;\n    });\n\n    pulse.visit(pulse.ADD, t => {\n      const dt = derive(t, ingest({}));\n      lut[tupleid(t)] = dt;\n      out.add.push(dt);\n    });\n\n    pulse.visit(pulse.MOD, t => {\n      out.mod.push(derive(t, lut[tupleid(t)]));\n    });\n\n    return out;\n  }\n});\n\nfunction project(s, t, fields, as) {\n  for (let i=0, n=fields.length; i<n; ++i) {\n    t[as[i]] = fields[i](s);\n  }\n  return t;\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Proxy the value of another operator as a pure signal value.\n * Ensures no tuples are propagated.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {*} params.value - The value to proxy, becomes the value of this operator.\n */\nexport default function Proxy(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Proxy, Transform, {\n  transform(_, pulse) {\n    this.value = _.value;\n    return _.modified('value')\n      ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS)\n      : pulse.StopPropagation;\n  }\n});\n","import {partition} from './util/util';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {quantiles} from 'vega-statistics';\nimport {accessorName, inherits} from 'vega-util';\nimport {range} from 'd3-array';\n\n/**\n * Generates sample quantile values from an input data stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - An accessor for the data field\n *   over which to calculate quantile values.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *   to groupby.\n * @param {Array<number>} [params.probs] - An array of probabilities in\n *   the range (0, 1) for which to compute quantile values. If not specified,\n *   the *step* parameter will be used.\n * @param {Array<number>} [params.step=0.01] - A probability step size for\n *   sampling quantile values. All values from one-half the step size up to\n *   1 (exclusive) will be sampled. This parameter is only used if the\n *   *quantiles* parameter is not provided.\n */\nexport default function Quantile(params) {\n  Transform.call(this, null, params);\n}\n\nQuantile.Definition = {\n  'type': 'Quantile',\n  'metadata': {'generates': true, 'changes': true},\n  'params': [\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'field', 'type': 'field', 'required': true },\n    { 'name': 'probs', 'type': 'number', 'array': true },\n    { 'name': 'step', 'type': 'number', 'default': 0.01 },\n    { 'name': 'as', 'type': 'string', 'array': true, 'default': ['prob', 'value'] }\n  ]\n};\n\nconst EPSILON = 1e-14;\n\ninherits(Quantile, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n          as = _.as || ['prob', 'value'];\n\n    if (this.value && !_.modified() && !pulse.changed()) {\n      out.source = this.value;\n      return out;\n    }\n\n    const source = pulse.materialize(pulse.SOURCE).source,\n          groups = partition(source, _.groupby, _.field),\n          names = (_.groupby || []).map(accessorName),\n          values = [],\n          step = _.step || 0.01,\n          p = _.probs || range(step/2, 1 - EPSILON, step),\n          n = p.length;\n\n    groups.forEach(g => {\n      const q = quantiles(g, p);\n\n      for (let i=0; i<n; ++i) {\n        const t = {};\n        for (let i=0; i<names.length; ++i) {\n          t[names[i]] = g.dims[i];\n        }\n        t[as[0]] = p[i];\n        t[as[1]] = q[i];\n        values.push(ingest(t));\n      }\n    });\n\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n\n    return out;\n  }\n});\n","import {Transform, derive, tupleid} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Relays a data stream between data processing pipelines.\n * If the derive parameter is set, this transform will create derived\n * copies of observed tuples. This provides derived data streams in which\n * modifications to the tuples do not pollute an upstream data source.\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.derive=false] - Boolean flag indicating if\n *   the transform should make derived copies of incoming tuples.\n * @constructor\n */\nexport default function Relay(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Relay, Transform, {\n  transform(_, pulse) {\n    let out, lut;\n\n    if (this.value) {\n      lut = this.value;\n    } else {\n      out = pulse = pulse.addAll();\n      lut = this.value = {};\n    }\n\n    if (_.derive) {\n      out = pulse.fork(pulse.NO_SOURCE);\n\n      pulse.visit(pulse.REM, t => {\n        const id = tupleid(t);\n        out.rem.push(lut[id]);\n        lut[id] = null;\n      });\n\n      pulse.visit(pulse.ADD, t => {\n        const dt = derive(t);\n        lut[tupleid(t)] = dt;\n        out.add.push(dt);\n      });\n\n      pulse.visit(pulse.MOD, t => {\n        const dt = lut[tupleid(t)];\n        for (const k in t) {\n          dt[k] = t[k];\n          // down stream writes may overwrite re-derived tuples\n          // conservatively mark all source fields as modified\n          out.modifies(k);\n        }\n        out.mod.push(dt);\n      });\n    }\n\n    return out;\n  }\n});\n","import {Transform, tupleid} from 'vega-dataflow';\nimport {random} from 'vega-statistics';\nimport {inherits} from 'vega-util';\n\n/**\n * Samples tuples passing through this operator.\n * Uses reservoir sampling to maintain a representative sample.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.size=1000] - The maximum number of samples.\n */\nexport default function Sample(params) {\n  Transform.call(this, [], params);\n  this.count = 0;\n}\n\nSample.Definition = {\n  'type': 'Sample',\n  'metadata': {},\n  'params': [\n    { 'name': 'size', 'type': 'number', 'default': 1000 }\n  ]\n};\n\ninherits(Sample, Transform, {\n  transform(_, pulse) {\n    const out = pulse.fork(pulse.NO_SOURCE),\n          mod = _.modified('size'),\n          num = _.size,\n          map = this.value.reduce((m, t) => (m[tupleid(t)] = 1, m), {});\n\n    let res = this.value,\n        cnt = this.count,\n        cap = 0;\n\n    // sample reservoir update function\n    function update(t) {\n      let p, idx;\n\n      if (res.length < num) {\n        res.push(t);\n      } else {\n        idx = ~~((cnt + 1) * random());\n        if (idx < res.length && idx >= cap) {\n          p = res[idx];\n          if (map[tupleid(p)]) out.rem.push(p); // eviction\n          res[idx] = t;\n        }\n      }\n      ++cnt;\n    }\n\n    if (pulse.rem.length) {\n      // find all tuples that should be removed, add to output\n      pulse.visit(pulse.REM, t => {\n        const id = tupleid(t);\n        if (map[id]) {\n          map[id] = -1;\n          out.rem.push(t);\n        }\n        --cnt;\n      });\n\n      // filter removed tuples out of the sample reservoir\n      res = res.filter(t => map[tupleid(t)] !== -1);\n    }\n\n    if ((pulse.rem.length || mod) && res.length < num && pulse.source) {\n      // replenish sample if backing data source is available\n      cap = cnt = res.length;\n      pulse.visit(pulse.SOURCE, t => {\n        // update, but skip previously sampled tuples\n        if (!map[tupleid(t)]) update(t);\n      });\n      cap = -1;\n    }\n\n    if (mod && res.length > num) {\n      const n = res.length-num;\n      for (let i=0; i<n; ++i) {\n        map[tupleid(res[i])] = -1;\n        out.rem.push(res[i]);\n      }\n      res = res.slice(n);\n    }\n\n    if (pulse.mod.length) {\n      // propagate modified tuples in the sample reservoir\n      pulse.visit(pulse.MOD, t => {\n        if (map[tupleid(t)]) out.mod.push(t);\n      });\n    }\n\n    if (pulse.add.length) {\n      // update sample reservoir\n      pulse.visit(pulse.ADD, update);\n    }\n\n    if (pulse.add.length || cap < 0) {\n      // output newly added tuples\n      out.add = res.filter(t => !map[tupleid(t)]);\n    }\n\n    this.count = cnt;\n    this.value = out.source = res;\n    return out;\n  }\n});\n","import {Transform, ingest} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\nimport {range} from 'd3-array';\n\n/**\n * Generates data tuples for a specified sequence range of numbers.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {number} params.start - The first number in the sequence.\n * @param {number} params.stop - The last number (exclusive) in the sequence.\n * @param {number} [params.step=1] - The step size between numbers in the sequence.\n */\nexport default function Sequence(params) {\n  Transform.call(this, null, params);\n}\n\nSequence.Definition = {\n  'type': 'Sequence',\n  'metadata': {'generates': true, 'changes': true},\n  'params': [\n    { 'name': 'start', 'type': 'number', 'required': true },\n    { 'name': 'stop', 'type': 'number', 'required': true },\n    { 'name': 'step', 'type': 'number', 'default': 1 },\n    { 'name': 'as', 'type': 'string', 'default': 'data' }\n  ]\n};\n\ninherits(Sequence, Transform, {\n  transform(_, pulse) {\n    if (this.value && !_.modified()) return;\n\n    const out = pulse.materialize().fork(pulse.MOD),\n          as = _.as || 'data';\n\n    out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;\n\n    this.value = range(_.start, _.stop, _.step || 1).map(v => {\n      const t = {};\n      t[as] = v;\n      return ingest(t);\n    });\n\n    out.add = pulse.add.concat(this.value);\n\n    return out;\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Propagates a new pulse without any tuples so long as the input\n * pulse contains some added, removed or modified tuples.\n * @param {object} params - The parameters for this operator.\n * @constructor\n */\nexport default function Sieve(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\ninherits(Sieve, Transform, {\n  transform(_, pulse) {\n    this.value = pulse.source;\n    return pulse.changed()\n      ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS)\n      : pulse.StopPropagation;\n  }\n});\n\n","import {Transform} from 'vega-dataflow';\nimport {\n  TIME_UNITS, timeBin, timeFloor, timeInterval, timeUnits,\n  utcFloor, utcInterval\n} from 'vega-time';\nimport {accessorFields, extent, inherits, peek} from 'vega-util';\n\n/**\n * Discretize dates to specific time units.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The data field containing date/time values.\n */\nexport default function TimeUnit(params) {\n  Transform.call(this, null, params);\n}\n\nconst OUTPUT = ['unit0', 'unit1'];\n\nTimeUnit.Definition = {\n  'type': 'TimeUnit',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'field', 'type': 'field', 'required': true },\n    { 'name': 'interval', 'type': 'boolean', 'default': true },\n    { 'name': 'units', 'type': 'enum', 'values': TIME_UNITS, 'array': true },\n    { 'name': 'step', 'type': 'number', 'default': 1 },\n    { 'name': 'maxbins', 'type': 'number', 'default': 40 },\n    { 'name': 'extent', 'type': 'date', 'array': true},\n    { 'name': 'timezone', 'type': 'enum', 'default': 'local', 'values': ['local', 'utc'] },\n    { 'name': 'as', 'type': 'string', 'array': true, 'length': 2, 'default': OUTPUT }\n  ]\n};\n\ninherits(TimeUnit, Transform, {\n  transform(_, pulse) {\n    const field = _.field,\n          band = _.interval !== false,\n          utc = _.timezone === 'utc',\n          floor = this._floor(_, pulse),\n          offset = (utc ? utcInterval : timeInterval)(floor.unit).offset,\n          as = _.as || OUTPUT,\n          u0 = as[0],\n          u1 = as[1],\n          step = floor.step;\n\n    let min = floor.start || Infinity,\n        max = floor.stop || -Infinity,\n        flag = pulse.ADD;\n\n    if (\n      _.modified() ||\n      pulse.changed(pulse.REM) ||\n      pulse.modified(accessorFields(field))\n    ) {\n      pulse = pulse.reflow(true);\n      flag = pulse.SOURCE;\n      min = Infinity;\n      max = -Infinity;\n    }\n\n    pulse.visit(flag, t => {\n      const v = field(t);\n      let a, b;\n      if (v == null) {\n        t[u0] = null;\n        if (band) t[u1] = null;\n      } else {\n        t[u0] = a = b = floor(v);\n        if (band) t[u1] = b = offset(a, step);\n        if (a < min) min = a;\n        if (b > max) max = b;\n      }\n    });\n\n    floor.start = min;\n    floor.stop = max;\n\n    return pulse.modifies(band ? as : u0);\n  },\n\n  _floor(_, pulse) {\n    const utc = _.timezone === 'utc';\n\n    // get parameters\n    const {units, step} = _.units\n      ? {units: _.units, step: _.step || 1}\n      : timeBin({\n        extent:  _.extent || extent(pulse.materialize(pulse.SOURCE).source, _.field),\n        maxbins: _.maxbins\n      });\n\n    // check / standardize time units\n    const tunits = timeUnits(units),\n          prev = this.value || {},\n          floor = (utc ? utcFloor : timeFloor)(tunits, step);\n\n    floor.unit = peek(tunits);\n    floor.units = tunits;\n    floor.step = step;\n    floor.start = prev.start;\n    floor.stop = prev.stop;\n    return this.value = floor;\n  }\n});\n","import {Transform} from 'vega-dataflow';\nimport {fastmap, inherits} from 'vega-util';\n\n/**\n * An index that maps from unique, string-coerced, field values to tuples.\n * Assumes that the field serves as a unique key with no duplicate values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The field accessor to index.\n */\nexport default function TupleIndex(params) {\n  Transform.call(this, fastmap(), params);\n}\n\ninherits(TupleIndex, Transform, {\n  transform(_, pulse) {\n    const df = pulse.dataflow,\n        field = _.field,\n        index = this.value,\n        set = t => index.set(field(t), t);\n\n    let mod = true;\n\n    if (_.modified('field') || pulse.modified(field.fields)) {\n      index.clear();\n      pulse.visit(pulse.SOURCE, set);\n    } else if (pulse.changed()) {\n      pulse.visit(pulse.REM, t => index.delete(field(t)));\n      pulse.visit(pulse.ADD, set);\n    } else {\n      mod = false;\n    }\n\n    this.modified(mod);\n    if (index.empty > df.cleanThreshold) df.runAfter(index.clean);\n    return pulse.fork();\n  }\n});\n","import {Transform, stableCompare} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Extracts an array of values. Assumes the source data has already been\n * reduced as needed (e.g., by an upstream Aggregate transform).\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The domain field to extract.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting the values. The comparator will be\n *   applied to backing tuples prior to value extraction.\n */\nexport default function Values(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Values, Transform, {\n  transform(_, pulse) {\n    const run = !this.value\n      || _.modified('field')\n      || _.modified('sort')\n      || pulse.changed()\n      || (_.sort && pulse.modified(_.sort.fields));\n\n    if (run) {\n      this.value = (_.sort\n        ? pulse.source.slice().sort(stableCompare(_.sort))\n        : pulse.source).map(_.field);\n    }\n  }\n});","import {error, zero} from 'vega-util';\n\nexport function WindowOp(op, field, param, as) {\n  const fn = WindowOps[op](field, param);\n  return {\n    init:   fn.init || zero,\n    update: function(w, t) { t[as] = fn.next(w); }\n  };\n}\n\nexport const WindowOps = {\n  row_number: function() {\n    return {\n      next: w => w.index + 1\n    };\n  },\n  rank: function() {\n    let rank;\n    return {\n      init: () => rank = 1,\n      next: w => {\n        const i = w.index,\n              data = w.data;\n        return (i && w.compare(data[i - 1], data[i])) ? (rank = i + 1) : rank;\n      }\n    };\n  },\n  dense_rank: function() {\n    let drank;\n    return {\n      init: () => drank = 1,\n      next: w => {\n        const i = w.index,\n              d = w.data;\n        return (i && w.compare(d[i - 1], d[i])) ? ++drank : drank;\n      }\n    };\n  },\n  percent_rank: function() {\n    const rank = WindowOps.rank(),\n          next = rank.next;\n    return {\n      init: rank.init,\n      next: w => (next(w) - 1) / (w.data.length - 1)\n    };\n  },\n  cume_dist: function() {\n    let cume;\n    return {\n      init: () => cume = 0,\n      next: w => {\n        const d = w.data,\n              c = w.compare;\n        let i = w.index;\n        if (cume < i) {\n          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;\n          cume = i;\n        }\n        return (1 + cume) / d.length;\n      }\n    };\n  },\n  ntile: function(field, num) {\n    num = +num;\n    if (!(num > 0)) error('ntile num must be greater than zero.');\n    const cume = WindowOps.cume_dist(),\n          next = cume.next;\n    return {\n      init: cume.init,\n      next: w => Math.ceil(num * next(w))\n    };\n  },\n\n  lag: function(field, offset) {\n    offset = +offset || 1;\n    return {\n      next: w => {\n        const i = w.index - offset;\n        return i >= 0 ? field(w.data[i]) : null;\n      }\n    };\n  },\n  lead: function(field, offset) {\n    offset = +offset || 1;\n    return {\n      next: w => {\n        const i = w.index + offset,\n            d = w.data;\n        return i < d.length ? field(d[i]) : null;\n      }\n    };\n  },\n\n  first_value: function(field) {\n    return {\n      next: w => field(w.data[w.i0])\n    };\n  },\n  last_value: function(field) {\n    return {\n      next: w => field(w.data[w.i1 - 1])\n    };\n  },\n  nth_value: function(field, nth) {\n    nth = +nth;\n    if (!(nth > 0)) error('nth_value nth must be greater than zero.');\n    return {\n      next: w => {\n        const i = w.i0 + (nth - 1);\n        return i < w.i1 ? field(w.data[i]) : null;\n      }\n    };\n  },\n\n  prev_value: function(field) {\n    let prev;\n    return {\n      init: () => prev = null,\n      next: w => {\n        const v = field(w.data[w.index]);\n        return v != null ? (prev = v) : prev;\n      }\n    };\n  },\n  next_value: function(field) {\n    let v, i;\n    return {\n      init: () => (v = null, i = -1),\n      next: w => {\n        const d = w.data;\n        return w.index <= i ? v\n          : (i = find(field, d, w.index)) < 0\n            ? (i = d.length, v = null)\n            : (v = field(d[i]));\n      }\n    };\n  }\n};\n\nfunction find(field, data, index) {\n  for (let n = data.length; index < n; ++index) {\n    const v = field(data[index]);\n    if (v != null) return index;\n  }\n  return -1;\n}\n\nexport const ValidWindowOps = Object.keys(WindowOps);\n","import {compileMeasures, createMeasure, measureName} from './AggregateOps';\nimport TupleStore from './TupleStore';\nimport {WindowOp, WindowOps} from './WindowOps';\nimport {accessorFields, accessorName, array, error, hasOwnProperty} from 'vega-util';\n\nexport default function WindowState(_) {\n  const ops = array(_.ops),\n        fields = array(_.fields),\n        params = array(_.params),\n        aggregate_params = array(_.aggregate_params),\n        as = array(_.as),\n        outputs = this.outputs = [],\n        windows = this.windows = [],\n        inputs = {},\n        map = {},\n        counts = [],\n        measures = [];\n\n  let countOnly = true;\n\n  function visitInputs(f) {\n    array(accessorFields(f)).forEach(_ => inputs[_] = 1);\n  }\n  visitInputs(_.sort);\n\n  ops.forEach((op, i) => {\n    const field = fields[i],\n          param = params[i],\n          aggregate_param = aggregate_params[i] || null,\n          mname = accessorName(field),\n          name = measureName(op, mname, as[i]);\n\n    visitInputs(field);\n    outputs.push(name);\n\n    // Window operation\n    if (hasOwnProperty(WindowOps, op)) {\n      windows.push(WindowOp(op, field, param, name));\n    }\n\n    // Aggregate operation\n    else {\n      if (field == null && op !== 'count') {\n        error('Null aggregate field specified.');\n      }\n      if (op === 'count') {\n        counts.push(name);\n        return;\n      }\n\n      countOnly = false;\n      let m = map[mname];\n      if (!m) {\n        m = (map[mname] = []);\n        m.field = field;\n        measures.push(m);\n      }\n      m.push(createMeasure(op, aggregate_param, name));\n    }\n  });\n\n  if (counts.length || measures.length) {\n    this.cell = cell(measures, counts, countOnly);\n  }\n\n  this.inputs = Object.keys(inputs);\n}\n\nconst prototype = WindowState.prototype;\n\nprototype.init = function() {\n  this.windows.forEach(_ => _.init());\n  if (this.cell) this.cell.init();\n};\n\nprototype.update = function(w, t) {\n  const cell = this.cell,\n        wind = this.windows,\n        data = w.data,\n        m = wind && wind.length;\n  let j;\n\n  if (cell) {\n    for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);\n    for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);\n    cell.set(t);\n  }\n  for (j = 0; j < m; ++j) wind[j].update(w, t);\n};\n\nfunction cell(measures, counts, countOnly) {\n  measures = measures.map(m => compileMeasures(m, m.field));\n\n  const cell = {\n    num:   0,\n    agg:   null,\n    store: false,\n    count: counts\n  };\n\n  if (!countOnly) {\n    var n = measures.length,\n        a = cell.agg = Array(n),\n        i = 0;\n    for (; i<n; ++i) a[i] = new measures[i](cell);\n  }\n\n  if (cell.store) {\n    var store = cell.data = new TupleStore();\n  }\n\n  cell.add = function(t) {\n    cell.num += 1;\n    if (countOnly) return;\n    if (store) store.add(t);\n    for (let i=0; i<n; ++i) {\n      a[i].add(a[i].get(t), t);\n    }\n  };\n\n  cell.rem = function(t) {\n    cell.num -= 1;\n    if (countOnly) return;\n    if (store) store.rem(t);\n    for (let i=0; i<n; ++i) {\n      a[i].rem(a[i].get(t), t);\n    }\n  };\n\n  cell.set = function(t) {\n    let i, n;\n\n    // consolidate stored values\n    if (store) store.values();\n\n    // update tuple properties\n    for (i=0, n=counts.length; i<n; ++i) t[counts[i]] = cell.num;\n    if (!countOnly) for (i=0, n=a.length; i<n; ++i) a[i].set(t);\n  };\n\n  cell.init = function() {\n    cell.num = 0;\n    if (store) store.reset();\n    for (let i=0; i<n; ++i) a[i].init();\n  };\n\n  return cell;\n}\n","import {groupkey} from './util/AggregateKeys';\nimport {ValidAggregateOps} from './util/AggregateOps';\nimport SortedList from './util/SortedList';\nimport {ValidWindowOps} from './util/WindowOps';\nimport WindowState from './util/WindowState';\nimport {Transform, stableCompare, tupleid} from 'vega-dataflow';\nimport {constant, inherits} from 'vega-util';\nimport {bisector} from 'd3-array';\n\n/**\n * Perform window calculations and write results to the input stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.\n * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors\n *   for data fields to use as inputs to window operations.\n * @param {Array<*>} [params.params] - An array of parameter values for window operations.\n * @param {Array<number>} [params.aggregate_params] - An optional array of parameter values for aggregation operations.\n * @param {Array<string>} [params.as] - An array of output field names for window operations.\n * @param {Array<number>} [params.frame] - Window frame definition as two-element array.\n * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row\n *   number alone, ignoring peers with identical sort values. If false (default),\n *   the window boundaries will be adjusted to include peer values.\n */\nexport default function Window(params) {\n  Transform.call(this, {}, params);\n  this._mlen = 0;\n  this._mods = [];\n}\n\nWindow.Definition = {\n  'type': 'Window',\n  'metadata': {'modifies': true},\n  'params': [\n    { 'name': 'sort', 'type': 'compare' },\n    { 'name': 'groupby', 'type': 'field', 'array': true },\n    { 'name': 'ops', 'type': 'enum', 'array': true, 'values': ValidWindowOps.concat(ValidAggregateOps) },\n    { 'name': 'params', 'type': 'number', 'null': true, 'array': true },\n    { 'name': 'aggregate_params', 'type': 'number', 'null': true, 'array': true},\n    { 'name': 'fields', 'type': 'field', 'null': true, 'array': true },\n    { 'name': 'as', 'type': 'string', 'null': true, 'array': true },\n    { 'name': 'frame', 'type': 'number', 'null': true, 'array': true, 'length': 2, 'default': [null, 0] },\n    { 'name': 'ignorePeers', 'type': 'boolean', 'default': false }\n  ]\n};\n\ninherits(Window, Transform, {\n  transform(_, pulse) {\n    this.stamp = pulse.stamp;\n\n    const mod = _.modified(),\n          cmp = stableCompare(_.sort),\n          key = groupkey(_.groupby),\n          group = t => this.group(key(t));\n\n    // initialize window state\n    let state = this.state;\n    if (!state || mod) {\n      state = this.state = new WindowState(_);\n    }\n\n    // partition input tuples\n    if (mod || pulse.modified(state.inputs)) {\n      this.value = {};\n      pulse.visit(pulse.SOURCE, t => group(t).add(t));\n    } else {\n      pulse.visit(pulse.REM, t => group(t).remove(t));\n      pulse.visit(pulse.ADD, t => group(t).add(t));\n    }\n\n    // perform window calculations for each modified partition\n    for (let i=0, n=this._mlen; i<n; ++i) {\n      processPartition(this._mods[i], state, cmp, _);\n    }\n    this._mlen = 0;\n    this._mods = [];\n\n    // TODO don't reflow everything?\n    return pulse.reflow(mod).modifies(state.outputs);\n  },\n\n  group(key) {\n    let group = this.value[key];\n\n    if (!group) {\n      group = this.value[key] = SortedList(tupleid);\n      group.stamp = -1;\n    }\n\n    if (group.stamp < this.stamp) {\n      group.stamp = this.stamp;\n      this._mods[this._mlen++] = group;\n    }\n\n    return group;\n  }\n});\n\nfunction processPartition(list, state, cmp, _) {\n  const sort = _.sort,\n        range = sort && !_.ignorePeers,\n        frame = _.frame || [null, 0],\n        data = list.data(cmp), // use cmp for stable sort\n        n = data.length,\n        b = range ? bisector(sort) : null,\n        w = {\n          i0: 0, i1: 0, p0: 0, p1: 0, index: 0,\n          data: data, compare: sort || constant(-1)\n        };\n\n  state.init();\n  for (let i=0; i<n; ++i) {\n    setWindow(w, frame, i, n);\n    if (range) adjustRange(w, b);\n    state.update(w, data[i]);\n  }\n}\n\nfunction setWindow(w, f, i, n) {\n  w.p0 = w.i0;\n  w.p1 = w.i1;\n  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));\n  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);\n  w.index = i;\n}\n\n// if frame type is 'range', adjust window for peer values\nfunction adjustRange(w, bisect) {\n  const r0 = w.i0,\n        r1 = w.i1 - 1,\n        c = w.compare,\n        d = w.data,\n        n = d.length - 1;\n\n  if (r0 > 0 && !c(d[r0], d[r0-1])) w.i0 = bisect.left(d, d[r0]);\n  if (r1 < n && !c(d[r1], d[r1+1])) w.i1 = bisect.right(d, d[r1]);\n}\n"],"names":["groupkey","fields","length","f","x","n","i","k","String","measureName","op","field","as","noop","base_op","init","add","rem","idx","AggregateOps","values","m","cell","store","value","data","count","num","__count__","missing","valid","sum","undefined","v","product","mean","mean_d","average","req","variance","dev","variancep","stdev","Math","sqrt","stdevp","stderr","distinct","get","ci0","ci1","median","q2","q1","q3","min","Number","isNaN","NaN","max","argmin","t","argmax","exponential","r","exp","exp_r","exponentialb","ValidAggregateOps","Object","keys","filter","d","createMeasure","param","name","compareIndex","a","b","this","_ops","forEach","aggregate_param","set","_out","out","compileMeasures","agg","identity","ops","map","getreqs","key","sort","resolve","slice","ctr","prototype","TupleStore","_key","tupleid","reset","extend","measure","Aggregate","params","Transform","call","_adds","_mods","_alen","_mlen","_drop","_cross","_dims","_dnames","_measures","_countOnly","_counts","_prev","_inputs","_outputs","prototype$1","_add","_rem","_ext","_get","_q","push","Array","j","s","hasOwnProperty","extent","extentIndex","quartile","quartiles","ci","_ci","bootstrapCI","Definition","type","metadata","generates","changes","array","null","default","inherits","transform","_","pulse","aggr","fork","NO_SOURCE","NO_FIELDS","mod","modified","stamp","create","visit","SOURCE","REM","ADD","modifies","drop","cross","clean","runAfter","curr","dims","vals","collect","cells","tuple","generate","base","index","inputs","outputs","inputMap","inputVisit","accessorFields","groupby","dname","accessorName","cellkey","aggregate_params","mname","outname","error","newcell","newtuple","measures","p","names","replace","ingest","celltuple","counts","adds","mods","prev","Bin","SortedList","idFunc","source","input","$","cnt","remove","size","compare","resort","merge","concat","Collect","Compare","Operator","update","orders","CountPattern","Cross","required","band","interval","bins","_bins","start","step","b0","b1","flag","reflow","ADD_MOD","bin","stop","ceil","anchor","floor","toNumber","Infinity","accessor","ALL","list","materialize","changed","stableCompare","root","process","tokens","text","tcase","match","toUpperCase","toLowerCase","tokenize","case","test","_parameterCheck","_match","_stop","_finish","RegExp","stopwords","pattern","tuples","_tuples","w","c","ADD_REM","left","truthy","Distributions","kde","randomKDE","mixture","randomMixture","normal","randomNormal","lognormal","randomLogNormal","uniform","randomUniform","FUNCTION","parse","def","func","from","Density","distributions","function","fieldNames","partition","groups","g","dist","parseDist","distribution","minsteps","steps","maxsteps","method","domain","sampleCurve","DotBin","Expression","expr","datum","Extent","Subflow","parent","Facet","_keys","fastmap","_targets","active","Field","isArray","Filter","Flatten","Fold","Formula","Generate","ascending","descending","zero","ascendingDefined","valueof","quickselect","arguments","right","TypeError","compareDefined","z","log","sd","swap","range","smooth","autostep","span","dotbin","isFinite","dataflow","warn","connect","target","detachSubflow","targets","evaluate","activate","flow","subflow","flows","df","sf","_group","detached","detach","initTargets","act","cache","rekey","group","id","delete","MOD","k0","k1","REFLOW","empty","cleanThreshold","output","isMod","revisit","has","arrays","maxlen","reduce","l","derive","fnames","initonly","gen","generator","Methods","Float64Array","numbers","i0","value0","subarray","quantile","Empty","Impute","JoinAggregate","KDE","Key","flat","Load","_pending","Lookup","MultiExtent","ext","extents","e","MultiValues","Params","Pivot","PreFacet","Project","Proxy","Quantile","gVals","kVal","impute","getValue","getField","fName","kName","gNames","keyvals","gKey","kMap","gMap","_impute","bandwidth","cumulative","density","scale","local","StopPropagation","format","async","request","url","then","res","touch","defaultValue","some","_transform","limit","pivotKeys","bind","aggregateParams","project","rederive","lut","addAll","dt","Relay","Sample","Sequence","Sieve","TimeUnit","probs","q","quantiles","cap","random","OUTPUT","TupleIndex","Values","TIME_UNITS","utc","timezone","_floor","offset","utcInterval","timeInterval","unit","u0","u1","units","timeBin","maxbins","tunits","timeUnits","utcFloor","timeFloor","peek","clear","WindowOps","row_number","next","rank","dense_rank","drank","percent_rank","cume_dist","cume","ntile","lag","lead","first_value","last_value","i1","nth_value","nth","prev_value","next_value","find","ValidWindowOps","WindowState","windows","countOnly","visitInputs","fn","WindowOp","Window","processPartition","state","cmp","ignorePeers","frame","compare1","compare2","delta","lo","hi","mid","center","bisector","p0","p1","constant","setWindow","adjustRange","abs","bisect","r0","r1","wind"],"mappings":"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","x_google_ignoreList":[24,25,26,27,28,29,30,31,33,34,35,36]}