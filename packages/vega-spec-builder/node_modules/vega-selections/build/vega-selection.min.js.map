{"version":3,"file":"vega-selection.min.js","sources":["../../../node_modules/d3-array/src/ascending.js","../../../node_modules/d3-array/src/descending.js","../../../node_modules/d3-array/src/bisector.js","../../../node_modules/internmap/src/index.js","../../../node_modules/d3-array/src/intersection.js","../src/util.js","../src/selectionTest.js","../src/selectionResolve.js","../../../node_modules/d3-array/src/union.js","../src/selectionTuples.js","../src/selectionVisitor.js"],"sourcesContent":["export default function ascending(a, b) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","export default function descending(a, b) {\n  return a == null || b == null ? NaN\n    : b < a ? -1\n    : b > a ? 1\n    : b >= a ? 0\n    : NaN;\n}\n","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We can’t do this\n  // for a comparator (except for specific, known comparators) because we can’t\n  // tell if the comparator is symmetric, and an asymmetric comparator can’t be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n","export class InternMap extends Map {\n  constructor(entries, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (entries != null) for (const [key, value] of entries) this.set(key, value);\n  }\n  get(key) {\n    return super.get(intern_get(this, key));\n  }\n  has(key) {\n    return super.has(intern_get(this, key));\n  }\n  set(key, value) {\n    return super.set(intern_set(this, key), value);\n  }\n  delete(key) {\n    return super.delete(intern_delete(this, key));\n  }\n}\n\nexport class InternSet extends Set {\n  constructor(values, key = keyof) {\n    super();\n    Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});\n    if (values != null) for (const value of values) this.add(value);\n  }\n  has(value) {\n    return super.has(intern_get(this, value));\n  }\n  add(value) {\n    return super.add(intern_set(this, value));\n  }\n  delete(value) {\n    return super.delete(intern_delete(this, value));\n  }\n}\n\nfunction intern_get({_intern, _key}, value) {\n  const key = _key(value);\n  return _intern.has(key) ? _intern.get(key) : value;\n}\n\nfunction intern_set({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) return _intern.get(key);\n  _intern.set(key, value);\n  return value;\n}\n\nfunction intern_delete({_intern, _key}, value) {\n  const key = _key(value);\n  if (_intern.has(key)) {\n    value = _intern.get(key);\n    _intern.delete(key);\n  }\n  return value;\n}\n\nfunction keyof(value) {\n  return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n}\n","import {InternSet} from \"internmap\";\n\nexport default function intersection(values, ...others) {\n  values = new InternSet(values);\n  others = others.map(set);\n  out: for (const value of values) {\n    for (const other of others) {\n      if (!other.has(value)) {\n        values.delete(value);\n        continue out;\n      }\n    }\n  }\n  return values;\n}\n\nfunction set(values) {\n  return values instanceof InternSet ? values : new InternSet(values);\n}\n","import {field} from 'vega-util';\n\n// Registers vega-util field accessors to protect against XSS attacks\nconst SELECTION_GETTER = Symbol('vega_selection_getter');\nexport function getter(f) {\n  if (!f.getter || !f.getter[SELECTION_GETTER]) {\n    f.getter = field(f.field);\n    f.getter[SELECTION_GETTER] = true;\n  }\n\n  return f.getter;\n}\n\nexport const Intersect = 'intersect';\nexport const Union = 'union';\nexport const VlMulti = 'vlMulti';\nexport const VlPoint = 'vlPoint';\nexport const Or = 'or';\nexport const And = 'and';\n\nexport const SelectionId = '_vgsid_';\nexport const $selectionId = field(SelectionId);\n","import {bisector} from 'd3-array';\nimport {inrange, isArray, isDate, toNumber} from 'vega-util';\nimport {$selectionId, Intersect, getter} from './util';\n\nconst TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    TYPE_PRED_LT = 'E-LT',\n    TYPE_PRED_LTE = 'E-LTE',\n    TYPE_PRED_GT = 'E-GT',\n    TYPE_PRED_GTE = 'E-GTE',\n    TYPE_PRED_VALID = 'E-VALID',\n    TYPE_PRED_ONE_OF = 'E-ONE',\n    UNIT_INDEX = 'index:unit';\n\n// TODO: revisit date coercion?\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0, dval, f;\n\n  for (; i<n; ++i) {\n    f = fields[i];\n    dval = getter(f)(datum);\n\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isArray(values[i]) && isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if(isArray(values[i]) ? !values[i].includes(dval) : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      } else if (f.type === TYPE_PRED_LT) {\n        if (dval >= values[i]) return false;\n      } else if (f.type === TYPE_PRED_LTE) {\n        if (dval > values[i]) return false;\n      } else if (f.type === TYPE_PRED_GT) {\n        if (dval <= values[i]) return false;\n      } else if (f.type === TYPE_PRED_GTE) {\n        if (dval < values[i]) return false;\n      } else if (f.type === TYPE_PRED_VALID) {\n        if (dval === null || isNaN(dval)) return false;\n      } else if (f.type === TYPE_PRED_ONE_OF) {\n        if (values[i].indexOf(dval) === -1) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *  Tuples in the dataset are of the form\n *  {unit: string, fields: array<fielddef>, values: array<*>}.\n *  Fielddef is of the form\n *  {field: string, channel: string, type: 'E' | 'R'} where\n *  'type' identifies whether tuples in the dataset enumerate\n *  values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\nexport function selectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      n = entries.length,\n      i = 0,\n      entry, miss, count, unit, b;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit=entry.unit] || 0;\n\n      // if we've already matched this unit, skip.\n      if (count === -1) continue;\n\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count;\n\n      // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry);\n\n      // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n      if (intersect ^ b) return b;\n    }\n  }\n\n  // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n  return n && intersect;\n}\n\nconst bisect = bisector($selectionId),\n  bisectLeft = bisect.left,\n  bisectRight = bisect.right;\n\nexport function selectionIdTest(name, datum, op) {\n  const data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === Intersect,\n      value = $selectionId(datum),\n      index = bisectLeft(entries, value);\n\n  if (index === entries.length) return false;\n  if ($selectionId(entries[index]) !== value) return false;\n\n  if (unitIdx && intersect) {\n    if (unitIdx.size === 1) return true;\n    if (bisectRight(entries, value) - index < unitIdx.size) return false;\n  }\n\n  return true;\n}\n","import {intersection, union} from 'd3-array';\nimport {array, toNumber} from 'vega-util';\nimport {$selectionId, And, Or, SelectionId, Union, VlMulti, VlPoint} from './util';\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @param {boolean} isMulti - Identifies a \"multi\" selection to perform more\n *                 expensive resolution computation.\n * @param {boolean} vl5 - With Vega-Lite v5, \"multi\" selections are now called \"point\"\n *                 selections, and thus the resolved tuple should reflect this name.\n *                 This parameter allows us to reflect this change without triggering\n *                 a major version bump for Vega.\n * @returns {object} An object of selected fields and values.\n */\nexport function selectionResolve(name, op, isMulti, vl5) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    resolved = {}, multiRes = {}, types = {},\n    entry, fields, values, unit, field, value, res, resUnit, type, union,\n    n = entries.length, i = 0, j, m;\n\n  // First union all entries within the same unit.\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    if (fields && values) { // Intentional selection stores\n      for (j = 0, m = fields.length; j < m; ++j) {\n        field = fields[j];\n        res = resolved[field.field] || (resolved[field.field] = {});\n        resUnit = res[unit] || (res[unit] = []);\n        types[field.field] = type = field.type.charAt(0);\n        union = ops[`${type}_union`];\n        res[unit] = union(resUnit, array(values[j]));\n      }\n\n      // If the same multi-selection is repeated over views and projected over\n      // an encoding, it may operate over different fields making it especially\n      // tricky to reliably resolve it. At best, we can de-dupe identical entries\n      // but doing so may be more computationally expensive than it is worth.\n      // Instead, for now, we simply transform our store representation into\n      // a more human-friendly one.\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push(array(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));\n      }\n    } else {  // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.\n      field = SelectionId;\n      value = $selectionId(entry);\n      res = resolved[field] || (resolved[field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      resUnit.push(value);\n\n      if (isMulti) {\n        resUnit = multiRes[unit] || (multiRes[unit] = []);\n        resUnit.push({[SelectionId]: value});\n      }\n    }\n  }\n\n  // Then resolve fields across units as per the op.\n  op = op || Union;\n  if (resolved[SelectionId]) {\n    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));\n  } else {\n    Object.keys(resolved).forEach(field => {\n      resolved[field] = Object.keys(resolved[field])\n        .map(unit => resolved[field][unit])\n        .reduce((acc, curr) => acc === undefined ? curr : ops[`${types[field]}_${op}`](acc, curr));\n    });\n  }\n\n  entries = Object.keys(multiRes);\n  if (isMulti && entries.length) {\n    const key = vl5 ? VlPoint : VlMulti;\n    resolved[key] = op === Union\n      ? {[Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])}\n      : {[And]: entries.map(k => ({[Or]: multiRes[k]}))};\n  }\n\n  return resolved;\n}\n\nvar ops = {\n  [`${SelectionId}_union`]: union,\n  [`${SelectionId}_intersect`]: intersection,\n\n  E_union: function(base, value) {\n    if (!base.length) return value;\n\n    var i = 0, n = value.length;\n    for (; i<n; ++i) if (!base.includes(value[i])) base.push(value[i]);\n    return base;\n  },\n\n  E_intersect: function(base, value) {\n    return !base.length ? value :\n      base.filter(v => value.includes(v));\n  },\n\n  R_union: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n\n  R_intersect: function(base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n    return base;\n  }\n};\n","import {InternSet} from \"internmap\";\n\nexport default function union(...others) {\n  const set = new InternSet();\n  for (const other of others) {\n    for (const o of other) {\n      set.add(o);\n    }\n  }\n  return set;\n}\n","import {extend} from 'vega-util';\nimport {$selectionId, SelectionId, getter} from './util';\n\n/**\n * Maps an array of scene graph items to an array of selection tuples.\n * @param {string} name  - The name of the dataset representing the selection.\n * @param {string} base  - The base object that generated tuples extend.\n *\n * @returns {array} An array of selection entries for the given unit.\n */\nexport function selectionTuples(array, base) {\n  return array.map(x => extend(\n    base.fields ? {\n      values: base.fields.map(f => getter(f)(x.datum))\n    } : {\n      [SelectionId]: $selectionId(x.datum)\n    }, base));\n}\n","import {Literal} from 'vega-expression';\nimport {error, hasOwnProperty, peek} from 'vega-util';\nimport {Intersect} from './util';\n\nconst DataPrefix = ':',\n      IndexPrefix = '@';\n\nexport function selectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to selection functions must be a string literal.');\n\n  const data = args[0].value,\n        op = args.length >= 2 && peek(args).value,\n        field = 'unit',\n        indexName = IndexPrefix + field,\n        dataName = DataPrefix + data;\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (op === Intersect && !hasOwnProperty(params, indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n\n  // eslint-disable-next-line no-prototype-builtins\n  if (!hasOwnProperty(params, dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n"],"names":["ascending","a","b","NaN","descending","zero","InternSet","Set","constructor","values","key","arguments","length","undefined","keyof","super","Object","defineProperties","this","_intern","value","Map","_key","add","has","_ref","get","intern_get","_ref2","set","intern_set","delete","_ref3","intern_delete","valueOf","SELECTION_GETTER","Symbol","getter","f","field","Intersect","Union","SelectionId","$selectionId","TYPE_ENUM","TYPE_RANGE_INC","TYPE_RANGE_EXC","TYPE_RANGE_LE","TYPE_RANGE_RE","TYPE_PRED_LT","TYPE_PRED_LTE","TYPE_PRED_GT","TYPE_PRED_GTE","TYPE_PRED_VALID","TYPE_PRED_ONE_OF","UNIT_INDEX","testPoint","datum","entry","dval","fields","n","i","isDate","toNumber","isArray","map","type","includes","inrange","isNaN","indexOf","bisect","compare1","compare2","delta","left","x","lo","hi","mid","d","center","right","bisector","bisectLeft","bisectRight","ops","_len","others","Array","other","o","out","E_union","base","push","E_intersect","filter","v","R_union","R_intersect","name","op","data","context","entries","unitIdx","intersect","index","size","isMulti","vl5","unit","res","resUnit","union","j","m","resolved","multiRes","types","charAt","array","reduce","obj","curr","keys","forEach","acc","or","k","and","miss","count","extend","args","scope","params","Literal","error","indexName","dataName","peek","hasOwnProperty","getData","indataRef","tuplesRef"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,8]}