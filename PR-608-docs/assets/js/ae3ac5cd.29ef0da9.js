"use strict";(self.webpackChunk_spectrum_charts_docs=self.webpackChunk_spectrum_charts_docs||[]).push([[864],{656:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/trendline_annotation_dark-f8e9ac78cdb86045a316e8d133d299b2.png"},1184:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var i=t(4041);const r={},s=i.createContext(r);function l(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(s.Provider,{value:n},e.children)}},4272:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/trendline_annotationTextCollisions_light-ba9302b46e51708d0e96cb9741303263.png"},6393:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"api/analysis/Trendline","title":"Trendline","description":"The Trendline component is used to add average lines, regression (trend) lines as well as moving average lines to a cartesean based plot like Area, Bar or Line. Trendline will add a single line of the provided variant to each series in the chart. Styling of the Trendline is inherited from the mark that it is attached to but it is possible to override these values with static values (for example: change the line type so all moving averages are dashed lines).","source":"@site/docs/api/analysis/Trendline.md","sourceDirName":"api/analysis","slug":"/api/analysis/Trendline","permalink":"/react-spectrum-charts/PR-608-docs/docs/api/analysis/Trendline","draft":false,"unlisted":false,"editUrl":"https://github.com/adobe/react-spectrum-charts/tree/main/packages/docs/docs/api/analysis/Trendline.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"MetricRange","permalink":"/react-spectrum-charts/PR-608-docs/docs/api/analysis/MetricRange"},"next":{"title":"Axis","permalink":"/react-spectrum-charts/PR-608-docs/docs/api/components/Axis"}}');var r=t(1085),s=t(1184);const l={},a=void 0,d={},o=[{value:"Statistical Calculations",id:"statistical-calculations",level:2},{value:"Regression",id:"regression",level:3},{value:"Time base regressions",id:"time-base-regressions",level:4},{value:"Window",id:"window",level:3},{value:"Examples",id:"examples",level:2},{value:"Average line on a bar chart",id:"average-line-on-a-bar-chart",level:3},{value:"Rolling 7 day average on a line chart",id:"rolling-7-day-average-on-a-line-chart",level:3},{value:"Props",id:"props",level:2},{value:"TrendlineAnnotation",id:"trendlineannotation",level:2},{value:"Text collisions",id:"text-collisions",level:3},{value:"Annotation position order",id:"annotation-position-order",level:4},{value:"Example",id:"example",level:4},{value:"Props",id:"props-1",level:3}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"Trendline"})," component is used to add average lines, regression (trend) lines as well as moving average lines to a cartesean based plot like ",(0,r.jsx)(n.code,{children:"Area"}),", ",(0,r.jsx)(n.code,{children:"Bar"})," or ",(0,r.jsx)(n.code,{children:"Line"}),". ",(0,r.jsx)(n.code,{children:"Trendline"})," will add a single line of the provided variant to each series in the chart. Styling of the ",(0,r.jsx)(n.code,{children:"Trendline"})," is inherited from the mark that it is attached to but it is possible to override these values with static values (for example: change the line type so all moving averages are dashed lines)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Trendline"}),"s do not get added to the legend. Only the parent marks get added to the legend."]}),"\n",(0,r.jsx)(n.h2,{id:"statistical-calculations",children:"Statistical Calculations"}),"\n",(0,r.jsxs)(n.p,{children:["You can define what type of trendline you want plotted using the ",(0,r.jsx)(n.code,{children:"method"})," property. ",(0,r.jsx)(n.code,{children:"method"})," supports ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Regression_analysis",children:"regressions"})," and ",(0,r.jsx)(n.a,{href:"https://vega.github.io/vega/docs/transforms/window/",children:"rolling windows"}),". ",(0,r.jsx)(n.code,{children:"react-spectrum-charts"})," will do all of the trendline transformations for you so there is no need to pre-calculate these values."]}),"\n",(0,r.jsx)(n.h3,{id:"regression",children:"Regression"}),"\n",(0,r.jsx)(n.p,{children:"A regression transform fits a two dimensional data set which can assist with identifying trends and anomalies. The two dimensional fit can be written out as an x, y equation (ex. linear equation: y = mx + b)."}),"\n",(0,r.jsxs)(n.p,{children:["One characteristic of regressions is they have a minimum number of data points required to be able to be calculated. The minimum number for most supported methods is 2, however the polynomial methods require 1 more data point than the order of the polynomial. For example, a ",(0,r.jsx)(n.code,{children:"polynomial-2"})," (",(0,r.jsx)(n.code,{children:"quadratic"}),") requires at least 3 data points to be calculated and a ",(0,r.jsx)(n.code,{children:"polynomial-9"})," would require at least 10 points. If there aren't sufficient points, the trendline may not draw at all."]}),"\n",(0,r.jsx)(n.p,{children:"Supported regression transforms:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["average: ",(0,r.jsx)(n.code,{children:"y = a"})]}),"\n",(0,r.jsxs)(n.li,{children:["linear: ",(0,r.jsx)(n.code,{children:"y = a + b * x"})]}),"\n",(0,r.jsxs)(n.li,{children:["logarithmic: ",(0,r.jsx)(n.code,{children:"y = a + b * log(x)"})]}),"\n",(0,r.jsxs)(n.li,{children:["exponential: ",(0,r.jsx)(n.code,{children:"y = a + exp(b * x)"})]}),"\n",(0,r.jsxs)(n.li,{children:["power: ",(0,r.jsx)(n.code,{children:"y = a * pow(x, b)"})]}),"\n",(0,r.jsxs)(n.li,{children:["quadratic: ",(0,r.jsx)(n.code,{children:"y = a + b * x + c * pow(x, 2)"})]}),"\n",(0,r.jsxs)(n.li,{children:["polynomial-${number}: ",(0,r.jsx)(n.code,{children:"y = a + b * x + ... + k * pow(x, order)"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Note: ",(0,r.jsx)(n.code,{children:"linear"})," is identical to ",(0,r.jsx)(n.code,{children:"polynomial-1"})," and ",(0,r.jsx)(n.code,{children:"quadratic"})," is identical to ",(0,r.jsx)(n.code,{children:"polynomial-2"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"time-base-regressions",children:"Time base regressions"}),"\n",(0,r.jsxs)(n.p,{children:["Timestamps in ",(0,r.jsx)(n.code,{children:"react-spectrum-charts"})," use unix time which is the milliseconds since Jan, 1st 1970 in London. This means that timestamps are on the order of 1.5 trillion. Using such large numbers for the x axis is problematic when calculating regressions. To solve this and get more value out of regression methods, ",(0,r.jsx)(n.code,{children:"react-spectrum-charts"})," normalizes timestamp dimensions so that the regressions are actually calculated using days since the beginning of time period + 1 day."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"normalizedTimestamp = (timestamp - timePeriodStart + msPerDay) / msPerDay;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"window",children:"Window"}),"\n",(0,r.jsxs)(n.p,{children:["A window transform performs calculations on a set window of data. There is only one window method currently supported which is ",(0,r.jsx)(n.code,{children:"movingAverage-$\\{number}"}),". This transform will average x number of data points leading up to the current data point. For example, if you used ",(0,r.jsx)(n.code,{children:"movingAverage-3"}),", then the 4th data point in the series would average the values of data points 2, 3, and 4 to calculate the 3 point moving average. One thing to note is if there aren't enough data points for the full window prior to the current point, the start of the window will truncate to the start of the data points. For example the ",(0,r.jsx)(n.code,{children:"movingAverage-3"})," of the 2nd data point would be the average of point 1 and 2."]}),"\n",(0,r.jsx)(n.p,{children:"Example"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"x"}),(0,r.jsx)(n.th,{children:"y"}),(0,r.jsx)(n.th,{style:{textAlign:"right"},children:"movingAverage-3"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{style:{textAlign:"right"},children:"4"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"2"}),(0,r.jsx)(n.td,{children:"6"}),(0,r.jsx)(n.td,{style:{textAlign:"right"},children:"5"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"3"}),(0,r.jsx)(n.td,{children:"8"}),(0,r.jsx)(n.td,{style:{textAlign:"right"},children:"6"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"4"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{style:{textAlign:"right"},children:"5"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"5"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{style:{textAlign:"right"},children:"3"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsx)(n.h3,{id:"average-line-on-a-bar-chart",children:"Average line on a bar chart"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Chart data={data}>\n  <Bar>\n    <Trendline method="average" color="gray-500" />\n  </Bar>\n</Chart>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"rolling-7-day-average-on-a-line-chart",children:"Rolling 7 day average on a line chart"}),"\n",(0,r.jsx)(n.p,{children:"For this example, the granularity of the data would be in days."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Chart data={data}>\n  <Line>\n    <Trendline method="movingAverage-7" lineType="dashed" />\n  </Line>\n</Chart>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"props",children:"Props"}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"name"}),(0,r.jsx)("th",{children:"type"}),(0,r.jsx)("th",{children:"default"}),(0,r.jsx)("th",{children:"description"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"children"}),(0,r.jsx)("td",{children:"ChartTooltip | TrendlineAnnotation"}),(0,r.jsx)("td",{children:"\u2013"}),(0,r.jsx)("td",{children:"Supplementary content to render with a trendline."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"color"}),(0,r.jsx)("td",{children:"SpectrumColor | CssColor"}),(0,r.jsx)("td",{children:"\u2013"}),(0,r.jsx)("td",{children:"The line color of the trendline. If undefined, will default to the color of the series that it represents."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"dimensionExtent"}),(0,r.jsx)("td",{children:"[number | 'domain' | null, number | 'domain' | null]"}),(0,r.jsx)("td",{children:"\u2013"}),(0,r.jsxs)("td",{children:["The start and end point for drawing the trendline. If undefined, will default to the value of the ",(0,r.jsx)(n.code,{children:"dimensionRange"}),". If 'domain' is used as a start or end value, this will extrapolate the trendline out to the beginning and end of the chart domain respectively. If null is used as a start or end value, the trendline will be be drawn from the first data point to the last data point respectively."]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"dimensionRange"}),(0,r.jsx)("td",{children:"[number | null, number | null]"}),(0,r.jsx)("td",{children:"[null, null]"}),(0,r.jsx)("td",{children:"The dimension range that the statistical tranform should be calculated and drawn for. If the start or end values are null, then the dimension range will not be bounded."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"displayOnHover"}),(0,r.jsx)("td",{children:"boolean"}),(0,r.jsx)("td",{children:"false"}),(0,r.jsx)("td",{children:"Whether the trendline should only be visible when hovering over the parent line."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"excludeDataKeys"}),(0,r.jsx)("td",{children:"string[]"}),(0,r.jsx)("td",{children:"-"}),(0,r.jsx)("td",{children:"If a chart datum has a truthy value for any of these keys, it will not be included in the trendline calculation."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"highlightRawPoint"}),(0,r.jsx)("td",{children:"boolean"}),(0,r.jsx)("td",{children:"false"}),(0,r.jsx)("td",{children:"If there is a tooltip on this trendline, then this will highlight the raw point in addition to the hovered trendline point."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"lineType"}),(0,r.jsx)("td",{children:"'solid' | 'dashed' | 'dotted' | 'dotDash' | 'shortDash' | 'longDash' | 'twoDash' | number[]"}),(0,r.jsx)("td",{children:"'solid'"}),(0,r.jsx)("td",{children:"The line type of the trend line."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"lineWidth"}),(0,r.jsx)("td",{children:"'XS' | 'S' | 'M' | 'L' | 'XL' | number"}),(0,r.jsx)("td",{children:"'M'"}),(0,r.jsx)("td",{children:"The line width of the trend line."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"method"}),(0,r.jsxs)("td",{children:["'average' | 'exponential' | 'linear' | 'logarithmic' | ",(0,r.jsx)(n.code,{children:"movingAverage-$\\{number}"})," | ",(0,r.jsx)(n.code,{children:"polynomial-$\\{number}"})," | 'power' | 'quadratic'"]}),(0,r.jsx)("td",{children:"'linear'"}),(0,r.jsx)("td",{children:"The type of statistical transform that will be calculated."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"name"}),(0,r.jsx)("td",{children:"string"}),(0,r.jsx)("td",{children:"\u2013"}),(0,r.jsx)("td",{children:"Trendline name. Useful for if you need to traverse the chart object to find the trendline (ex. for testing)."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"opacity"}),(0,r.jsx)("td",{children:"number"}),(0,r.jsx)("td",{children:"\u2013"}),(0,r.jsx)("td",{children:"If provided, sets the opacity of the trendlines."})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"trendlineannotation",children:"TrendlineAnnotation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Trendline annotation",src:t(7298).A+"#gh-light-mode-only",width:"500",height:"500"}),"\n",(0,r.jsx)(n.img,{alt:"Trendline annotation",src:t(656).A+"#gh-dark-mode-only",width:"500",height:"500"})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"TrendlineAnnotation"})," component will render a text annotation on the trendline, calling out the trendline value at the point. ",(0,r.jsx)(n.code,{children:"TrendlineAnnotation"})," can be defined as a child of a ",(0,r.jsx)(n.code,{children:"Trendline"}),". If an annotation cannot be rendered without overlapping over graphical marks or text, it will not be rendered. Because of this, ",(0,r.jsx)(n.code,{children:"TrendlineAnnotation"}),'s should be thought of as "nice to haves".']}),"\n",(0,r.jsx)(n.h3,{id:"text-collisions",children:"Text collisions"}),"\n",(0,r.jsxs)(n.p,{children:["Annotations on a trendline use logic to identify if the annotation will overlap any of the underlying marks (",(0,r.jsx)(n.code,{children:"Scatter"}),", ",(0,r.jsx)(n.code,{children:"Line"}),", etc.), the ",(0,r.jsx)(n.code,{children:"Trendline"}),", and even other annotations. If an annotation would overlap other graphical marks or text, then the logic will cycle through the available render positions to see if it can render the annotation without overlapping (see order of annotation position below). If so, it will render in that position and if not, the annotation will not be rendered."]}),"\n",(0,r.jsx)(n.h4,{id:"annotation-position-order",children:"Annotation position order"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"top"}),"\n",(0,r.jsx)(n.li,{children:"bottom"}),"\n",(0,r.jsx)(n.li,{children:"right"}),"\n",(0,r.jsx)(n.li,{children:"left"}),"\n",(0,r.jsx)(n.li,{children:"top-right"}),"\n",(0,r.jsx)(n.li,{children:"top-left"}),"\n",(0,r.jsx)(n.li,{children:"bottom-right"}),"\n",(0,r.jsx)(n.li,{children:"bottom-left"}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'<Chart {...chartProps}>\n  <Axis position="bottom" grid ticks baseline title="Speed (normal)" />\n  <Axis position="left" grid ticks baseline title="Handling (normal)" />\n  <Scatter color="weightClass" dimension="speedNormal" metric="handlingNormal">\n    <Trendline method="median" dimensionExtent={[\'domain\', \'domain\']} lineWidth="S">\n      <TrendlineAnnotation dimensionValue="end" prefix="Speed:" />\n    </Trendline>\n  </Scatter>\n  <Legend title="Weight class" highlight position="right" />\n  <Title text="Mario Kart 8 Character Data" />\n</Chart>\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.img,{alt:"Trendline annotation text collision",src:t(4272).A+"#gh-light-mode-only",width:"500",height:"500"}),"\n",(0,r.jsx)(n.img,{alt:"Trendline annotation text collision",src:t(6430).A+"#gh-dark-mode-only",width:"500",height:"500"})]}),"\n",(0,r.jsx)(n.p,{children:"In the chart above, the annoations are being displayed at the end of the trendline. The first annotation attempted to place the text at top, bottom, right, left, and top-right (all relative to the end point) but all of these failed since there wasn't enough room. Finally it attempted to place the text at the top-left (relative to the end point) and was successful. The same goes for the second annotation. The third annotation was not able to find any position that it could place the text without a collision so the annotation was not rendered."}),"\n",(0,r.jsx)(n.h3,{id:"props-1",children:"Props"}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"name"}),(0,r.jsx)("th",{children:"type"}),(0,r.jsx)("th",{children:"default"}),(0,r.jsx)("th",{children:"description"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"badge"}),(0,r.jsx)("td",{children:"boolean"}),(0,r.jsx)("td",{children:"false"}),(0,r.jsx)("td",{children:"Displays the annotation text as a badge. Contrast checker is used on the annotation text to ensure a contrast greater that 3.5 when compared to the badge color."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"dimensionValue"}),(0,r.jsx)("td",{children:"'start' | 'end' | number"}),(0,r.jsx)("td",{children:"'end'"}),(0,r.jsx)("td",{children:"Where on the dimension axis to place the trendline annotation anchor."})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"numberFormat"}),(0,r.jsx)("td",{children:"string"}),(0,r.jsx)("td",{children:"''"}),(0,r.jsxs)("td",{children:["Sets the format of the displayed trendline value. This format must be a ",(0,r.jsx)("a",{href:"https://d3js.org/d3-format#locale_format",target:"_blank",children:"d3-format specifier"})," (Example: '$.2f' = $5,432.10). ",(0,r.jsx)("a",{href:"https://github.com/adobe/react-spectrum-charts/wiki/Chart-API#locale",target:"_blank",children:"Number locale"})," will be applied to the number format."]})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"prefix"}),(0,r.jsx)("td",{children:"string"}),(0,r.jsx)("td",{children:"''"}),(0,r.jsx)("td",{children:"Text string that will prefix the trendline value"})]})]})]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},6430:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/trendline_annotationTextCollisions_dark-267aa330726031e932a15b173f0855a0.png"},7298:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/trendline_annotation_light-c21ae1547b79b951c5d128627e47b159.png"}}]);